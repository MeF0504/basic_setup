#! /usr/bin/env python3
# pseudo-tree command

import os
import argparse
import re
from pathlib import Path
import datetime
from stat import filemode
from fnmatch import fnmatchcase

from pymeflib.tree import show_tree

debug = False


def get_pattern_from_file(exfiles):
    res = []
    if exfiles is None:
        return res

    for exfile in exfiles:
        exfile = Path(exfile)
        if not exfile.is_file():
            print('exfile {} is not readable'.format(exfile))
            continue

        with open(exfile, 'r') as f:
            for line in f:
                line = line.replace('\n', '')
                if re.match('\s*#', line):
                    continue
                res.append(line)
    return res


def get_file_list(args):
    # get list of directories and files by using pathlib
    file_list = [{}]
    # top_path = Path(args.root).resolve()
    top_path = Path(args.root)
    expatrns = get_pattern_from_file(args.exfiles)
    root = str(top_path)
    if args.maxdepth == 0:
        glob_path = ['**/*']
    else:
        glob_path = []
        for i in range(args.maxdepth):
            glob_path.append('*/'*i)
            glob_path[i] += '*'

    tmp_list = file_list
    for gp in glob_path:
        if debug:
            print('<--{}-->'.format(gp))
        for cpath in top_path.glob(gp):
            if (args.exclude is not None) and\
               re.search(args.exclude, str(cpath)):
                continue
            skip = False
            for expt in expatrns:
                if fnmatchcase(str(cpath), expt):
                    skip = True
                    break
            if skip:
                continue

            if not args.all:
                if cpath.name.startswith('.'):
                    continue
                cpath_ignore = False
                for d in cpath.parents:
                    if d == top_path:
                        break
                    if str(d.name).startswith('.'):
                        cpath_ignore = True
                        break
                if cpath_ignore:
                    continue

            if debug:
                print('cpath: {},\n  parent: {}'.format(cpath, cpath.relative_to(top_path).parent))
            tmp_list = file_list
            for par in cpath.relative_to(top_path).parts[:-1]:
                if debug:
                    print('par: {}'.format(par))
                if str(par) == '.':
                    continue
                tmp_list = tmp_list[0][str(par)]
            if debug:
                print('file_list:{},\n tmp_list:{}'.format(file_list, tmp_list))
            if cpath.is_dir():
                tmp_list[0][str(cpath.name)] = [{}]
            else:
                tmp_list.append(str(cpath.name))
    return root, file_list


def get_file_info(fpath):
    if not os.path.exists(fpath):
        # bloken link
        return '\tfile not exists.'

    stat = os.stat(fpath)

    # access
    access = filemode(stat.st_mode)

    # time stamp
    # meta data update (UNIX), created (Windows)
    # dt = datetime.datetime.fromtimestamp(stat.st_ctime)
    # created (some OS)
    # dt = datetime.datetime.fromtimestamp(stat.st_birthtime)
    # last update
    dt = datetime.datetime.fromtimestamp(stat.st_mtime)
    # last access
    # dt = datetime.datetime.fromtimestamp(stat.st_atime)
    timestamp = dt.strftime('%Y/%m/%d-%H:%M:%S')

    # file size
    filesize = os.path.getsize(fpath)
    prefix = ''
    if filesize > 1024**3:
        filesize /= 1024**3
        prefix = 'G'
    elif filesize > 1024**2:
        filesize /= 1024**2
        prefix = 'M'
    elif filesize > 1024:
        filesize /= 1024
        prefix = 'k'
    size = '({:.1f} {}B)'.format(filesize, prefix)

    # symbolic link
    if os.path.islink(fpath):
        realpath = '-> '+os.path.realpath(fpath)
    else:
        realpath = ''

    return '\t{} {} {} {}'.format(access, size, timestamp, realpath)


def main(args):
    root, file_list = get_file_list(args)
    if args.verbose:
        add_info = get_file_info
    else:
        add_info = None
    show_tree(file_list, root, add_info)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('root', help='root directory', nargs='?', default='.')
    parser.add_argument('-a', dest='all', help='do not ignore entries starting with .', action='store_true')
    parser.add_argument('-v', '--verbose', help='show the verbose.', action='store_true')
    parser.add_argument('-maxdepth', help='specify the level of directory. If set 0, show all directories.', type=int, default=0)
    parser.add_argument('-exclude', help='specify excluding patterns using regular expression.', type=str)
    parser.add_argument('-exfiles', help='specify excluding patterns from pattern files written in shell-style wildcards, like gitignore.', type=str, nargs='*')
    # parser.add_argument('--walk', help='use os.walk', action='store_true')
    args = parser.parse_args()
    main(args)
