#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim: set filetype=python:

import os
import sys
import argparse
import tarfile
from pathlib import PurePath

from libtree import tree_viewer, show_tree, branch_str
from local_lib import chk_cmd

try:
    from color_test import BG, FG, END
except ImportError:
    print_color = False
else:
    print_color = True

debug = False
inter_str = "'q':quit, '..':go to parent, key_name:select a key >> "

def args_chk(args, attr):
    if not hasattr(args, attr):
        return False
    if attr == 'type':
        return args.type is not None
    elif attr == 'verbose':
        return args.verbose
    elif attr == 'key':
        return args.key is not None
    elif attr == 'interactive':
        return args.interactive

def cprint(str1, str2='', fg=None, bg=None, **kwargs):
    print_str = str1
    if print_color:
        if fg is not None:
            print_str = FG[fg]+print_str
        if bg is not None:
            print_str = BG[bg]+print_str
        if (fg is not None) or (bg is not None):
            print_str += END
    print_str += str2
    print(print_str, **kwargs)

def interactive_view(tree, fname, show_func):
    cpath = PurePath('.')
    inter_str = "'q':quit, '..':go to parent, key_name:select a key >> "
    tv = tree_viewer(tree, '.')
    while(True):
        files, dirs = tv.get_contents(cpath)
        cprint('current path:', ' {}/{}'.format(fname, cpath), bg='c')
        cprint('contents in this dict:', ' ', bg='g', end='')
        for d in dirs:
            print('{}/, '.format(d), end='')
        for f in files:
            print('{}, '.format(f), end='')
        print('\n')
        key_name = input(inter_str)
        if key_name == 'q':
            if debug: print('quit')
            break
        elif key_name == '':
            if debug: print('continue')
            continue
        elif key_name == '..':
            if debug: print('go up')
            if str(cpath) != '.':
                cpath = cpath.parent
        else:
            if debug: print('specify key:{}'.format(key_name))
            if key_name.endswith('/'):
                key_name = key_name[:-1]
            if key_name in files:
                cprint('output::', '\n', bg='r')
                show_func(str(cpath/key_name))
            elif key_name in dirs:
                cpath /= key_name
            else:
                cprint('"{}" is not a correct name'.format(key_name), '', fg='r')

def print_key(key_name):
    cprint('<<< {} >>>'.format(key_name), '', fg='w', bg='b')

def main_hdf5(fpath, args):
    import h5py

    def show_hdf5(cpath):
        data = h5_file[cpath]
        if isinstance(data, h5py.Group):
            for k in data.keys():
                print(k)
        elif isinstance(data, h5py.Dataset):
            print(data[()])

    list_tree = [{}]
    def make_list(name, obj):
        if isinstance(obj, h5py.Dataset):
            if not args_chk(args, 'interactive'):
                if args_chk(args, 'verbose'):
                    print("--- {} ---\n{}".format(name, h5_file[name][()]))
                elif args_chk(args, 'key') and len(args.key)==0:
                    print(name)

            tmp_list = list_tree
            for p in name.split('/'):
                if p == name.split('/')[-1]:
                    tmp_list.append(p)
                    if debug:
                        print('add {} to {}'.format(p, tmp_list))
                elif p in tmp_list[0]:
                    tmp_list = tmp_list[0][p]
                else:
                    tmp_list[0][p] = [{}]
                    tmp_list = tmp_list[0][p]

    h5_file = h5py.File(fpath, 'r')
    # make list_tree
    h5_file.visititems(make_list)

    if args_chk(args, 'interactive'):
        fname = os.path.basename(fpath)
        interactive_view(list_tree, fname, show_hdf5)
    elif args_chk(args, 'key'):
        for k in args.key:
            print_key(k)
            show_hdf5(k)
            print()
    else:
        show_tree(list_tree)

    h5_file.close()

# {{{
# def main_pickle(fpath, args):
#     import pickle
#     try:
#         with open(fpath, 'rb') as f:
#             data = pickle.load(f)
#     except UnicodeDecodeError:
#         with open(fpath, 'rb') as f:
#             data = pickle.load(f, encoding='latin1')
# 
#     tree_data = [{}]
#     data_contents = {}
#     tmp_data = data
#     tmp_tree = tree_data
#     # how to make tree_list from dictionary?
#     # while(True):
#     #     if type(tmp_data) == type(dict()):
#     #         for k in tmp_data.keys():
#     #             tree_data[0][k] = [{}]
#     # if debug:
#     #     print(tree_data, data_contents)
# 
#     if type(data) == type(dict()):
#         if args_chk(args, 'key'):
#             if args.key in data:
#                 print(data[args.key])
#             else:
#                 print('{} is not in {}'.format(args.key, fpath.split(os.sep)[-1]))
#         elif args_chk(args, 'interactive'):
#             print(1)
#         elif
#     else:
#         print(data)
# }}}

# It is difficult to rebuild a recursive dictionary by any means...
def main_pickle(fpath, args):
    import pickle
    try:
        import numpy as np
    except ImportError:
        imp_np = False
    else:
        imp_np = True
    try:
        with open(fpath, 'rb') as f:
            data = pickle.load(f)
    except UnicodeDecodeError:
        with open(fpath, 'rb') as f:
            data = pickle.load(f, encoding='latin1')

    if type(data) == type(dict()):
        if args_chk(args, 'key'):
            if len(args.key)==0:
                for k in data:
                    print(k)
            else:
                for k in data:
                    if str(k) in args.key:
                        print_key(str(k))
                        print(data[k])
                        print()
        elif hasattr(args, 'interactive') and args.interactive:
            selected_keys = []
            tmp_data = data
            while(True):
                key_strs = [str(k) for k in selected_keys]
                cpath = '{}/{}'.format(os.path.basename(fpath), '/'.join(key_strs))
                cprint('current path:', ' {}'.format(cpath), bg='c')
                cprint('contents in this dict:', ' ', bg='g', end='')
                try:
                    tmp_keys = sorted(tmp_data.keys())
                except TypeError:
                    tmp_keys = tmp_data.keys()
                for i,k in enumerate(tmp_keys):
                    # print('|{} {}\n (type:{})'.format(i, k, type(tmp_data[k]).__name__), end=' ')
                    print('{},'.format(k), end='  ')
                print('\n')
                key_name = input(inter_str)
                if key_name == 'q':
                    break
                elif key_name == '':
                    continue
                elif key_name == '..':
                    if len(selected_keys) >= 1:
                        selected_keys = selected_keys[:-1]
                        tmp_data = data
                        for sk in selected_keys:
                            tmp_data = tmp_data[sk]
                    else:
                        cprint('you are in root.\n', '', fg='r')
                else:
                    find_key = False
                    for k in tmp_data:
                        if str(k) == key_name:
                            find_key = True
                            if type(tmp_data[k]) == dict:
                                tmp_data = tmp_data[k]
                                selected_keys.append(k)
                            else:
                                cprint('output::', '\n{}'.format(tmp_data[k]), bg='r')
                                if imp_np:
                                    if type(tmp_data[k])==np.ndarray:
                                        print('>> shape: {}, mean: {:.2e}, median: {:.2e}, std: {:.2e}'.format(tmp_data[k].shape, np.mean(tmp_data[k]), np.median(tmp_data[k]), np.std(tmp_data[k])))
                                print('')
                    if not find_key:
                        cprint('"{}" is not a correct name'.format(key_name), '', fg='r')
        else:
            try:
                tmp_keys = sorted(data.keys())
            except TypeError:
                tmp_keys = data.keys()
            for key in tmp_keys:
                print(key)
                if args.verbose:
                    print(' >>> {}'.format(data[key]))
                else:
                    print('  type   : {}'.format(type(data[key]).__name__))
                    if hasattr(data[key], '__len__'):
                        print('  length : {}'.format(len(data[key])))
    else:
        print(data)


def main_numpy(fpath, args):
    import numpy as np
    from numpy.lib.npyio import NpzFile
    def show_numpy(data):
        d_mean = np.mean(data)
        d_max = np.max(data)
        d_min = np.min(data)
        if np.isnan(d_mean):
            d_mean = np.nanmean(data)
            d_max = np.nanmax(data)
            d_min = np.nanmin(data)
            nan_rate = 1 - np.sum(data==data)/np.prod(data.shape)
        prt_str = '''shape    : {}
mean     : {}
max      : {}
min      : {} '''.format(data.shape, d_mean, d_max, d_min)
        if 'nan_rate' in locals():
            prt_str += '\nnan rate : {:.1f}%'.format(nan_rate*100)
        print(prt_str)

    data = np.load(fpath)
    if args_chk(args, 'verbose'):
        if type(data) == NpzFile:
            for k in data:
                print_key(k)
                print(data[k])
        else:
            print(data)
    elif args_chk(args, 'key'):
        if type(data) == NpzFile:
            if len(args.key)==0:
                for k in data:
                    print(k)
            for k in args.key:
                print_key(k)
                print(data[k])
                show_numpy(data[k])
                print()
    else:
        if type(data) == NpzFile:
            for k in data:
                print('\n{}'.format(k))
                show_numpy(data[k])
        else:
            show_numpy(data)

def main_tar(fpath, args):
    if not tarfile.is_tarfile(fpath):
        print('{} is not a tar file.'.format(fpath))
        return
    tar_file = tarfile.open(fpath, 'r:*')
    list_tree = [{}]
    fname = os.path.basename(fpath)

    def show_tar(cpath):
        try:
            if cpath.endswith('/'):
                key_name = cpath[:-1]
            else:
                key_name = cpath
            tarinfo = tar_file.getmember(key_name)
        except KeyError as e:
            print('Error!! cannnot open {}.'.format(cpath), file=sys.stderr)
            return
        if tarinfo.isfile():
            for line in tar_file.extractfile(cpath):
                try:
                    print(line.decode(), end='')
                except UnicodeDecodeError as e:
                    print('Error!! {}'.format(e), file=sys.stderr)
                    return
            print('')
        elif tarinfo.isdir():
            tree = tree_viewer(list_tree, fname)
            print('{}/'.format(key_name))
            files, dirs = tree.get_contents(key_name)
            for f in files:
                print('{}{}'.format(branch_str, f))
            for d in dirs:
                print('{}{}/'.format(branch_str, d))
        else:
            cprint('sorry, I can\'t show information.\n', '', fg='r')

    # make list_tree
    for t in tar_file:
        tmp_list = list_tree
        tnames = t.name.split('/')
        for p in tnames:
            if p == '': continue
            if (p==tnames[-1]) and t.isfile():
                tmp_list.append(p)
                if debug:
                    print('add {} to {}'.format(p, tmp_list))
            elif p in tmp_list[0]:
                tmp_list = tmp_list[0][p]
            else:
                tmp_list[0][p] = [{}]
                tmp_list = tmp_list[0][p]
    if debug:
        print(list_tree)

    if args_chk(args, 'interactive'):
        interactive_view(list_tree, fname, show_tar)
    elif args_chk(args, 'key'):
        if len(args.key)==0:
            tar_file.list(verbose=False)
        for k in args.key:
            print_key(k)
            show_tar(k)
            print()
    elif args_chk(args, 'verbose'):
        tar_file.list(verbose=True)
    else:
        show_tree(list_tree, fname)

    tar_file.close()

def main_zip(fpath, args):
    import zipfile
    if not zipfile.is_zipfile(fpath):
        print('{} is not a zip file.'.format(fpath))
        return
    zip_file = zipfile.ZipFile(fpath, 'r')
    list_tree = [{}]
    fname = os.path.basename(fpath)

    def show_zip(cpath):
        try:
            key_name = cpath
            if key_name+'/' in zip_file.namelist():
                key_name += '/'
            zipinfo = zip_file.getinfo(key_name)
        except KeyError as e:
            if debug:
                print(e)
            print('Error!! cannnot open {}.'.format(cpath), file=sys.stderr)
            return
        if zipinfo.is_dir():
            tree = tree_viewer(list_tree, fname)
            print('{}/'.format(key_name))
            files, dirs = tree.get_contents(key_name)
            for f in files:
                print('{}{}'.format(branch_str, f))
            for d in dirs:
                print('{}{}/'.format(branch_str, d))
        else:
            for line in zip_file.open(cpath, 'r'):
                try:
                    print(line.decode(), end='')
                except UnicodeDecodeError as e:
                    print('Error!! {}'.format(e), file=sys.stderr)
                    return

    # make list_tree
    for z in zip_file.infolist():
        tmp_list = list_tree
        znames = z.filename.split('/')
        for p in znames:
            if p == '': continue
            if (p==znames[-1]) and not z.is_dir():
                tmp_list.append(p)
                if debug:
                    print('add {} to {}'.format(p, tmp_list))
            elif p in tmp_list[0]:
                tmp_list = tmp_list[0][p]
            else:
                tmp_list[0][p] = [{}]
                tmp_list = tmp_list[0][p]
    if debug:
        print()
        print(list_tree)

    if args_chk(args, 'interactive'):
        interactive_view(list_tree, fname, show_zip)
    elif args_chk(args, 'key'):
        if len(args.key)==0:
            for fy in zip_file.namelist():
                print(fy)
        for k in args.key:
            print_key(k)
            show_zip(k)
            print()
    elif args_chk(args, 'verbose'):
        zip_file.printdir()
    else:
        show_tree(list_tree, fname)

    zip_file.close()

def main_sqlite3(fpath, args):
    import sqlite3
    try:
        from tabulate import tabulate
    except ImportError:
        print("I can't find tabulate library.")
        is_tabulate = False
    else:
        is_tabulate = True
    shift = '  '

    def show_table(table_path, verbose=True):
        if '/' in table_path:
            table, column = table_path.split('/')
            if column == '':
                column = None
            if debug:
                print('table, column: {}, {}'.format(table, column))
        else:
            table = table_path
            column = None
            if debug:
                print('table: {}'.format(table))
        cursor.execute("pragma table_info('{}')".format(table))
        table_info = cursor.fetchall()

        print(table)
        if not verbose:
            for tinfo in table_info:
                if tinfo[2] == '':
                    ctype = 'none'
                else:
                    ctype = tinfo[2]
                print('{}{} [ {} ]'.format(branch_str, tinfo[1], ctype))

        else:
            if column is None:
                headers = []
                for tinfo in table_info:
                    headers.append(tinfo[1])
                cursor.execute('select * from {}'.format(table))
            else:
                headers = column.split(',')
                cursor.execute('select {} from {}'.format(column, table))
            columns = cursor.fetchall()
            table = []
            for col in columns:
                table.append([])
                for item in col:
                    table[-1].append(item)

            if is_tabulate:
                table_str = tabulate(table, headers, tablefmt='orgtbl')
                table_str = table_str.replace('\n', '\n'+shift)
                print(shift + table_str)
            else:
                print(shift+'|', end='')
                for hd in headers:
                    print(' {} |'.format(hd), end='')
                print('')
                for itms in table:
                    print(shift+'|', end='')
                    for itm in itms:
                        print(' {} |'.format(itm), end='')
                    print('')

    database = sqlite3.connect(fpath)
    cursor = database.cursor()
    cursor.execute("select name from sqlite_master where type='table'")
    tables = cursor.fetchall()

    if args_chk(args, 'interactive'):
        # make list_tree
        list_tree = [{}]
        for table, in tables:
            if debug:
                print(table)
            list_tree[0][table] = [{}]
            cursor.execute("pragma table_info('{}')".format(table))
            table_info = cursor.fetchall()
            for tinfo in table_info:
                if debug:
                    print(tinfo)
                name = tinfo[1]
                list_tree[0][table].append(name)
        if debug:
            print(list_tree)
        fname = os.path.basename(fpath)
        interactive_view(list_tree, fname, show_table)
    elif args_chk(args, 'key'):
        if len(args.key)==0:
            for t in tables:
                print(t[0])
        for k in args.key:
            print_key(k)
            show_table(k, verbose=True)
            print()
    else:
        for table, in tables:
            show_table(table, args.verbose)

def main_raw(fpath, args):
    try:
        import rawpy
    except ImportError:
        print("I can't find rawpy.")
        return

    try:
        from PIL import Image, ImageShow
    except ImportError:
        try:
            import matplotlib.pyplot as plt
        except ImportError:
            print("I can't find any libraries to show image. Please install Pillow or matplotlib.")
            return
        else:
            img_lib = 'matplotlib'
    else:
        img_lib = 'PIL'

    try:
        from screeninfo import get_monitors
    except ImportError:
        get_screen = False
    else:
        get_screen = True

    with rawpy.imread(fpath) as raw:
        rgb = raw.postprocess()

    if debug:
        print(rgb.shape)
        print('use {}'.format(img_lib))
    if img_lib == 'PIL':
        img = Image.fromarray(rgb)
        ImageShow.show(img, title=os.path.basename(fpath))
    elif img_lib == 'matplotlib':
        if get_screen:
            height = get_monitors()[0].height
        else:
            height = 1080   # assume a full-HD display
        rate = rgb.shape[0]/height*100
        h = int(rgb.shape[0]/rate)
        w = int(rgb.shape[1]/rate)
        fig1 = plt.figure(figsize=(w,h))
        # full display
        ax1 = fig1.add_axes((0, 0, 1, 1))
        ax1.imshow(rgb)
        # not display axes
        ax1.xaxis.set_visible(False)
        ax1.yaxis.set_visible(False)
        ax1.spines['top'].set_visible(False)
        ax1.spines['bottom'].set_visible(False)
        ax1.spines['right'].set_visible(False)
        ax1.spines['left'].set_visible(False)
        plt.show()

def main_jupyter(fpath, args):
    import json
    import base64
    if chk_cmd('gosr'):
        import subprocess
        import tempfile
        is_term = True
        is_disp = True
    else:
        is_term = False
        try:
            from PIL import Image
            import io
            is_disp = True
        except ImportError as e:
            if debug: print(e)
            print('Images are not shown in this configuration. If you want to, please install Pillow.')
            is_disp = False

    with open(fpath, 'r') as f:
        data = json.load(f)
    if debug:
        print('keys: {}'.format(data.keys()))

    if args_chk(args, 'verbose'):
        meta = data['metadata']
        if debug: print(meta)
        print('kernel   : {}'.format(meta['kernelspec']['display_name']))
        if 'language_info' in meta:
            print('language : {}-{}'.format( \
                    meta['language_info']['name'], \
                    meta['language_info']['version']))
        if 'colab' in meta:
            print('colab : {}'.format(meta['colab']['name']))

    for cell in data['cells']:
        if debug:
            print(' ---- cell ----')
            print(cell)
            print('---------------')
        if cell['cell_type'] == 'code':
            cnt = cell['execution_count']
            if cnt is None:
                cnt = ' '
            # Input
            cprint('In [{}]'.format(cnt), fg='c')
            for instr in cell['source']:
                print(instr, end='')
            print()
            # Output
            if len(cell['outputs']) != 0:
                cprint('Out [{}]'.format(cnt), fg='r')
            for output in cell['outputs']:
                if 'text' in output:
                    for text in output['text']:
                        print(text, end='')
                    print()
                elif 'data' in output:
                    out_data = output['data']
                    for out_type in out_data:
                        if out_type == 'text/plain':
                            for text in out_data['text/plain']:
                                print(text, end='')
                            print()
                        elif out_type == 'image/png':
                            if not is_disp:
                                continue
                            img_code = out_data['image/png']
                            img_bin = base64.b64decode(img_code.encode())
                            if is_term:
                                with tempfile.NamedTemporaryFile() as tmp:
                                    tmp.write(img_bin)
                                    subprocess.call('gosr {}'.format(tmp.name), shell=True)
                            else:
                                with Image.open(io.BytesIO(img_bin)) as img:
                                    # title doesn't work?
                                    img.show(title='Out [{}]'.format(cnt))

        elif cell['cell_type'] == 'markdown':
            cprint('markdown', fg='g')
            for instr in cell['source']:
                print(instr, end='')
            print()

        elif cell['cell_type'] == 'raw':
            cprint('raw', fg='g')
            for instr in cell['source']:
                print(instr, end='')
            print()

        else:
            if debug:
                print('not a supported type of cell: {}'.format(cell['cell_type']))

        if not args_chk(args, 'verbose'):
            input(' >>> Press ENTER to continue')

def main(args):

    fpath = os.path.expanduser(args.file)
    if not os.path.exists(fpath):
        print("file doesn't exists!")
        return

    if not args_chk(args, 'type'):
        ext = fpath[fpath.rfind('.')+1:].lower()
        if ext == 'hdf5':
            args.type = 'hdf5'
        elif ext == 'pkl' or ext == 'pickle':
            args.type = 'pickle'
        elif ext in 'npy npz'.split(' '):
            args.type = 'numpy'
        elif tarfile.is_tarfile(fpath):
            args.type = 'tar'
        elif ext == 'zip':
            args.type = 'zip'
        elif ext in 'db db3 sql sql3 sqlite sqlite3'.split(' '):
            args.type = 'sqlite3'
        elif ext in 'raw nef nrw cr3 cr2 crw tif arw'.split(' '):   # nikon, canon, sony
            args.type = 'raw_image'
        elif ext == 'ipynb':
            args.type = 'jupyter'
        elif ext == 'py':
            if 'ja_JP' in os.environ['LANG']:
                print('vimでも使ってろ！')
            else:
                print("Why Don't you use vim???")
            return

    if args.type == 'hdf5':
        main_hdf5(fpath, args)
    elif args.type == 'pickle':
        main_pickle(fpath, args)
    elif args.type == 'numpy':
        main_numpy(fpath, args)
    elif args.type == 'tar':
        main_tar(fpath, args)
    elif args.type == 'zip':
        main_zip(fpath, args)
    elif args.type == 'sqlite3':
        main_sqlite3(fpath, args)
    elif args.type == 'raw_image':
        main_raw(fpath, args)
    elif args.type == 'jupyter':
        main_jupyter(fpath, args)
    else:
        print('this file is not supported.')

    return

if __name__ == "__main__":
    supported_type = 'hdf5, pickle, numpy, tar, zip, sqlite3, raw_image, jupyter'
    parser = argparse.ArgumentParser(description="show the constitution of a file. support file types ... {}".format(supported_type))
    parser.add_argument('file', help='input file')
    parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='show details')
    parser.add_argument('-t', '--type', dest='type', help='file type', choices=supported_type.split(', '))
    parser.add_argument('-k', '--key', dest='key', help='Dictionary key name in a pickle, path to a Group/Dataset in hdf5, a path to a file/dictionary in tar/zip, a table[/column[,column2...]] in sqlite3 or a key name in npz. If no key is specified, return the list of keys.', nargs='*')
    parser.add_argument('-i', '--interactive', dest='interactive', help='(beta ver.) open a file with interactive mode. support pickle, hdf5, tar, zip, sqlite3.', action='store_true')
    args = parser.parse_args()

    main(args)

