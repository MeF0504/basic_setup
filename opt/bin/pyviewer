#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim: set filetype=python:

import os
import sys
import argparse
import tarfile
import platform
import mimetypes
from pathlib import PurePath
try:
    # to use this, libmagic.* should be in /opt/local/lib/, /usr/local/lib, /opt/homebrew/lib or /usr/local/Cellar/libmagic/*/lib in darwin system (macOS).
    import magic
except ImportError as e:
    use_magic = False
else:
    use_magic = True

try:
    from libtree import tree_viewer, show_tree, branch_str
except ImportError as e:
    available_libtree = False
    branch_str  = '|__ '
else:
    available_libtree = True

try:
    from local_lib_color import BG, FG, END
except ImportError:
    print_color = False
else:
    print_color = True

debug = False
inter_str = "'q':quit, '..':go to parent, key_name:select a key >> "
uname = platform.system()

def args_chk(args, attr):
    if not hasattr(args, attr):
        return False
    if attr == 'type':
        return args.type is not None
    elif attr == 'verbose':
        return args.verbose
    elif attr == 'key':
        return args.key is not None
    elif attr == 'interactive':
        return args.interactive
    elif attr == 'image_viewer':
        return args.image_viewer is not None
    elif attr == 'opts':
        return args.opts is not None
    elif attr == 'encoding':
        return args.encoding is not None
    elif attr == 'exec':
        return args.exec is not None
    else:
        return False

def cprint(str1, str2='', fg=None, bg=None, **kwargs):
    print_str = str1
    if print_color:
        if fg is not None:
            print_str = FG[fg]+print_str
        if bg is not None:
            print_str = BG[bg]+print_str
        if (fg is not None) or (bg is not None):
            print_str += END
    print_str += str2
    print(print_str, **kwargs)

def get_filetype(fpath):
    ext = fpath[fpath.rfind('.')+1:].lower()
    if ext == 'hdf5':
        return 'hdf5'
    elif ext == 'pkl' or ext == 'pickle':
        return 'pickle'
    elif ext in 'npy npz'.split(' '):
        return 'numpy'
    elif tarfile.is_tarfile(fpath):
        return 'tar'
    elif ext == 'zip':
        return 'zip'
    elif ext in 'db db3 sql sql3 sqlite sqlite3'.split(' '):
        return 'sqlite3'
    elif ext in 'raw nef nrw cr3 cr2 crw tif arw'.split(' '):   # nikon, canon, sony
        return 'raw_image'
    elif ext == 'ipynb':
        return 'jupyter'
    elif ext == 'xpm':
        return 'xpm'
    elif ext == 'py':
        return 'text'
    else:
        return None

def get_filetype_magic(fpath):
    mime = magic.from_file(fpath, mime=True)
    if mime == 'inode/symlink':
        fpath = os.path.realpath(fpath)
        # fpath = os.readlink(fpath) which is better?
        mime = magic.from_file(fpath, mime=True)
    ext = fpath[fpath.rfind('.')+1:].lower()
    if debug:
        print('mime: {}'.format(mime))

    if tarfile.is_tarfile(fpath):
        return 'tar'
    elif mime == 'application/x-hdf':
        return 'hdf5'
    elif mime == 'application/x-numpy-data':
        return 'numpy'
    elif mime == 'application/zip':
        if ext == 'npz':
            return 'numpy'
        else:
            return 'zip'
    elif mime == 'application/x-sqlite3':
        return 'sqlite3'
    elif mime == 'image/tiff':
        return 'raw_image'
    elif mime in 'application/json text/x-tex'.split(' '):
        return 'jupyter'
    elif mime in 'image/x-xpmi image/x-xpixmap'.split(' '):
        return 'xpm'
    elif mime == 'text/plain':
        if ext == 'pkl' or ext == 'pickle':
            return 'pickle'
        elif ext == 'xpm':
            return 'xpm'
        else:
            return 'text'
    elif 'text' in mime:
        return 'text'
    else:
        return None

def is_image(path):
    mime = mimetypes.guess_type(path)[0]
    if mime.split('/')[0] == 'image':
        return True
    else:
        return False

def get_image_viewer(args):
    if args_chk(args, 'image_viewer'):
        img_viewer = args.image_viewer
        if img_viewer == 'PIL':
            from PIL import Image
            global Image
        elif img_viewer == 'matplotlib':
            import matplotlib.pyplot as plt
            global plt
        elif img_viewer == 'OpenCV':
            import cv2
            global cv2
        else:
            # external command
            img_viewer = os.path.expanduser(img_viewer)
            img_viewer = os.path.expandvars(img_viewer)
            if os.path.isfile(img_viewer) and os.access(img_viewer, os.X_OK):
                if debug:
                    print('find image_viewer: {}'.format(img_viewer))
                return img_viewer
            else:
                if 'PATH' in os.environ:
                    for path in os.environ['PATH'].split(os.pathsep):
                        cmd_path = os.path.join(path, img_viewer)
                        if os.path.isfile(cmd_path) and os.access(cmd_path, os.X_OK):
                            if debug:
                                print('find image_viewer {} in {}'.format(img_viewer, path))
                            return img_viewer
                    print('external command "{}" is not found.'.format(img_viewer))
                    return None
                else:
                    print('PATH is not set')
                    return None
    else:
        if debug:
            print('search available image_viewer')
        try:
            from PIL import Image
            global Image
            if debug: print(' => image_viewer: PIL')
        except ImportError:
            try:
                import matplotlib.pyplot as plt
                global plt
                if debug: print(' => image_viewer: matplotlib')
            except ImportError:
                try:
                    import cv2
                    global cv2
                    if debug: print(' => image_viewer: OpenCV')
                except ImportError:
                    if debug: print("can't find image_viewer")
                    img_viewer = None
                else:
                    img_viewer = 'OpenCV'
            else:
                img_viewer = 'matplotlib'
        else:
            img_viewer = 'PIL'
    return img_viewer

def get_exec_cmds(args, fname):
    if args_chk(args, 'exec'):
        res = []
        for cmd in args.exec:
            if cmd == '%s':
                res.append(fname)
            elif cmd == '%c':
                res.append(args.image_viewer)
            else:
                res.append(cmd)
    else:
        res = [args.image_viewer, fname]
    if debug:
        print('executed command: {}'.format(res))
    return res

def make_bitmap(filename, rgb, bmp_type='Windows'):
    if rgb.shape[-1] == 4:
        rgb = rgb[:,:,[0,1,2]]

    height, width, cols = rgb.shape
    if debug:
        print('{}x{}x{}'.format(height, width, cols))
        print('bitmap type: {}'.format(bmp_type))

    # make color table (it doesn't need in 24bmp format.)
    q_bit = 256
    color_table = []
    # for r in range(q_bit):
    #     for g in range(q_bit):
    #         for b in range(q_bit):
    #             color_table += [int(b), int(g), int(r), int(0)]
    # if debug:
    #     print('color table: ({}); {}...'.format(len(color_table), color_table[:10]))
    len_cols = len(color_table)
    num_cols = len(color_table)>>2

    # make pixel data
    img_data = []
    for i in range(height):
        line_data = []
        for j in range(width):
            r, g, b = rgb[height-i-1,j]     # starts from left botom
            line_data += [b, g, r]
        # line length should be a multiple of 4 bytes (long).
        padding = 4*(int((len(line_data)-1)/4)+1)-len(line_data)
        for k in range(padding):
            line_data.append(0)
        img_data += line_data
    if debug:
        print_st = '{}, '.format(img_data[0])
        print_end = '{}'.format(img_data[-1])
        for i in range(1,6):
            print_st += '{}, '.format(img_data[i])
            print_end = '{}, '.format(img_data[-i-1]) + print_end
        print('pixel data: ({}); [{} ... {}]'.format(len(img_data), print_st, print_end))
    len_data = len(img_data)

    if bmp_type == 'Windows':
        offset = 0x0e+0x28+len_cols
    elif bmp_type == 'OS/2':
        offset = 0x0e+0x0c+len_cols
    else:
        print('incorrect file format: {}.'.format(bmp_type), file=sys.stderr)
        return None
    file_size = offset+len_data

    # make binary data
    # FILE_HEADER
    b = bytearray([0x42, 0x4d])                 # signature 'BM'
    b.extend(file_size.to_bytes(4, 'little'))   # file size
    b.extend((0).to_bytes(2, 'little'))         # reserved
    b.extend((0).to_bytes(2, 'little'))         # reserved
    b.extend(offset.to_bytes(4, 'little'))      # offset

    # INFO_HEADER
    if bmp_type == 'Windows':
        b.extend((0x28).to_bytes(4, 'little'))      # size of header
        b.extend(width.to_bytes(4, 'little'))       # width [dot]
        b.extend(height.to_bytes(4, 'little'))      # height [dot]
        b.extend((1).to_bytes(2, 'little'))         # number of planes
        b.extend((8*3).to_bytes(2, 'little'))       # byte/1pixel
        b.extend((0).to_bytes(4, 'little'))         # type of compression (0=BI_RGB, no compression)
        b.extend(len_data.to_bytes(4, 'little'))     # size of image
        b.extend((0).to_bytes(4, 'little'))         # horizontal resolution
        b.extend((0).to_bytes(4, 'little'))         # vertical resolution
        b.extend(num_cols.to_bytes(4, 'little'))    # number of colors (not used for 24bmp)
        b.extend((0).to_bytes(4, 'little'))         # import colors (0=all)
    elif bmp_type == 'OS/2':
        b.extend((0x0c).to_bytes(4, 'little'))      # size of header
        b.extend(width.to_bytes(2, 'little'))       # width [dot]
        b.extend(height.to_bytes(2, 'little'))      # height [dot]
        b.extend((1).to_bytes(2, 'little'))         # number of planes
        b.extend((8*3).to_bytes(2, 'little'))       # byte/1pixel

    # COLOR_TABLES
    b.extend(color_table)

    # DATA
    b.extend(img_data)

    with open(filename, 'wb') as f:
        f.write(b)

    if debug:
        filesize = os.path.getsize(filename)
        prefix = ''
        if filesize > 1024**3:
            filesize /= 1024**3
            prefix = 'G'
        elif filesize > 1024**2:
            filesize /= 1024**2
            prefix = 'M'
        elif filesize > 1024:
            filesize /= 1024
            prefix = 'k'
        print('size of made file: {:.1f} {}B'.format(filesize, prefix))

def interactive_view(tree, fname, show_func):
    if not available_libtree:
        cprint('libtree is not available. exit.', fg='r', file=sys.stderr)
        return
    cpath = PurePath('.')
    inter_str = "'q':quit, '..':go to parent, key_name:select a key >> "
    tv = tree_viewer(tree, '.')
    while(True):
        files, dirs = tv.get_contents(cpath)
        cprint('current path:', ' {}/{}'.format(fname, cpath), bg='c')
        cprint('contents in this dict:', ' ', bg='g', end='')
        for d in dirs:
            print('{}/, '.format(d), end='')
        for f in files:
            print('{}, '.format(f), end='')
        print('\n')
        key_name = input(inter_str)
        if key_name == 'q':
            if debug: print('quit')
            break
        elif key_name == '':
            if debug: print('continue')
            continue
        elif key_name == '..':
            if debug: print('go up')
            if str(cpath) != '.':
                cpath = cpath.parent
        else:
            if debug: print('specify key:{}'.format(key_name))
            if key_name.endswith('/'):
                key_name = key_name[:-1]
            if key_name in files:
                cprint('output::', '\n', bg='r')
                show_func(str(cpath/key_name))
            elif key_name in dirs:
                cpath /= key_name
            else:
                cprint('"{}" is not a correct name'.format(key_name), '', fg='r')

def print_key(key_name):
    cprint('<<< {} >>>'.format(key_name), '', fg='k', bg='y')

def main_hdf5(fpath, args):
    if not available_libtree:
        cprint('libtree is not available. exit.', fg='r', file=sys.stderr)
        return
    import h5py
    try:
        import numpy as np
    except ImportError as e:
        imp_np = False
    else:
        imp_np = True

    def show_hdf5(cpath):
        data = h5_file[cpath]
        cprint('attrs', fg='k', bg='w')
        for attr in data.attrs:
            print('{}: {}'.format(attr, data.attrs[attr]))
        if isinstance(data, h5py.Group):
            cprint('contents', fg='k', bg='w')
            for k in data.keys():
                print(k)
        elif isinstance(data, h5py.Dataset):
            cprint('value', fg='k', bg='w')
            data = data[()]
            print(data)
            if hasattr(data, 'shape'):
                print('shape: {}'.format(data.shape))
                is_array = True
            elif hasattr(data, '__len__'):
                print('len: {}'.format(len(data)))
                is_array = True
            else:
                is_array = False
            if imp_np and is_array and (len(data)!=0):
                try: dmean = np.nanmean(data)
                except Exception as e: dmean = '{}: {}'.format(str(type(e)).split("'")[1], e)
                print('mean : {}'.format(dmean))
                try: dmax = np.nanmax(data)
                except Exception as e: dmax = '{}: {}'.format(str(type(e)).split("'")[1], e)
                print(' max : {}'.format(dmax))
                try: dmin = np.nanmin(data)
                except Exception as e: dmin = '{}: {}'.format(str(type(e)).split("'")[1], e)
                print(' min : {}'.format(dmin))
                try: dstd = np.nanstd(data)
                except Exception as e: dstd = '{}: {}'.format(str(type(e)).split("'")[1], e)
                print(' std : {}'.format(dstd))
                if hasattr(data, 'shape'):
                    try:
                        nan_rate = np.sum(np.isnan(data))/np.prod(data.shape)
                        print('nan rate: {:.1f}%'.format(nan_rate*100))
                    except Exception as e:
                        pass

    list_tree = [{}]
    def make_list(name, obj):
        if isinstance(obj, h5py.Dataset):
            if not args_chk(args, 'interactive'):
                if args_chk(args, 'verbose'):
                    print_key(name)
                    print("{}".format(h5_file[name][()]))
                elif args_chk(args, 'key') and len(args.key)==0:
                    print(name)

            tmp_list = list_tree
            depth = 1
            for p in name.split('/'):
                if p == name.split('/')[-1] and depth==len(name.split('/')):
                    tmp_list.append(p)
                    if debug:
                        print('add {} to {} @ {:d}'.format(p, tmp_list, depth))
                elif p in tmp_list[0]:
                    tmp_list = tmp_list[0][p]
                    depth += 1
                else:
                    tmp_list[0][p] = [{}]
                    tmp_list = tmp_list[0][p]
                    depth += 1

    h5_file = h5py.File(fpath, 'r')
    # make list_tree
    h5_file.visititems(make_list)

    if args_chk(args, 'interactive'):
        fname = os.path.basename(fpath)
        interactive_view(list_tree, fname, show_hdf5)
    elif args_chk(args, 'key'):
        for k in args.key:
            print_key(k)
            show_hdf5(k)
            print()
    elif not args_chk(args, 'verbose'):
        show_tree(list_tree)

    h5_file.close()

# {{{
# def main_pickle(fpath, args):
#     import pickle
#     try:
#         with open(fpath, 'rb') as f:
#             data = pickle.load(f)
#     except UnicodeDecodeError:
#         with open(fpath, 'rb') as f:
#             data = pickle.load(f, encoding='latin1')
# 
#     tree_data = [{}]
#     data_contents = {}
#     tmp_data = data
#     tmp_tree = tree_data
#     # how to make tree_list from dictionary?
#     # while(True):
#     #     if type(tmp_data) == type(dict()):
#     #         for k in tmp_data.keys():
#     #             tree_data[0][k] = [{}]
#     # if debug:
#     #     print(tree_data, data_contents)
# 
#     if type(data) == type(dict()):
#         if args_chk(args, 'key'):
#             if args.key in data:
#                 print(data[args.key])
#             else:
#                 print('{} is not in {}'.format(args.key, fpath.split(os.sep)[-1]))
#         elif args_chk(args, 'interactive'):
#             print(1)
#         elif
#     else:
#         print(data)
# }}}

# It is difficult to rebuild a recursive dictionary by any means...
def main_pickle(fpath, args):
    import pickle
    try:
        import numpy as np
    except ImportError:
        imp_np = False
    else:
        imp_np = True

    if args_chk(args, 'encoding'): encoding = args.encoding
    else: encoding = 'ASCII'
    try:
        with open(fpath, 'rb') as f:
            data = pickle.load(f, encoding=encoding)
    except UnicodeDecodeError:
        if debug: print('decode error: encoding={}'.format(encoding))
        with open(fpath, 'rb') as f:
            data = pickle.load(f, encoding='latin1')

    if type(data) == type(dict()):
        if args_chk(args, 'key'):
            if len(args.key)==0:
                for k in data:
                    print(k)
            else:
                for k in data:
                    if str(k) in args.key:
                        print_key(str(k))
                        print(data[k])
                        print()
        elif hasattr(args, 'interactive') and args.interactive:
            selected_keys = []
            tmp_data = data
            while(True):
                key_strs = [str(k) for k in selected_keys]
                cpath = '{}/{}'.format(os.path.basename(fpath), '/'.join(key_strs))
                cprint('current path:', ' {}'.format(cpath), bg='c')
                cprint('contents in this dict:', ' ', bg='g', end='')
                try:
                    tmp_keys = sorted(tmp_data.keys())
                except TypeError:
                    tmp_keys = tmp_data.keys()
                for i,k in enumerate(tmp_keys):
                    # print('|{} {}\n (type:{})'.format(i, k, type(tmp_data[k]).__name__), end=' ')
                    print('{},'.format(k), end='  ')
                print('\n')
                key_name = input(inter_str)
                if key_name == 'q':
                    break
                elif key_name == '':
                    continue
                elif key_name == '..':
                    if len(selected_keys) >= 1:
                        selected_keys = selected_keys[:-1]
                        tmp_data = data
                        for sk in selected_keys:
                            tmp_data = tmp_data[sk]
                    else:
                        cprint('you are in root.\n', '', fg='r')
                else:
                    find_key = False
                    for k in tmp_data:
                        if str(k) == key_name:
                            find_key = True
                            if type(tmp_data[k]) == dict:
                                tmp_data = tmp_data[k]
                                selected_keys.append(k)
                            else:
                                cprint('output::', '\n{}'.format(tmp_data[k]), bg='r')
                                if imp_np:
                                    if (type(tmp_data[k])==np.ndarray) and (len(tmp_data[k])!=0):
                                        try: dmean = np.mean(tmp_data[k])
                                        except Exception as e: dmean = '{}: {}'.format(str(type(e)).split("'")[1], e)
                                        try: dmedian = np.median(tmp_data[k])
                                        except Exception as e: dmedian = '{}: {}'.format(str(type(e)).split("'")[1], e)
                                        try: dstd = np.std(tmp_data[k])
                                        except Exception as e: dstd = '{}: {}'.format(str(type(e)).split("'")[1], e)
                                        print('>> shape: {}, mean: {:.2e}, median: {:.2e}, std: {:.2e}'.format(tmp_data[k].shape, dmean, dmedian, dstd))
                                print('')
                    if not find_key:
                        cprint('"{}" is not a correct name'.format(key_name), '', fg='r')
        else:
            try:
                tmp_keys = sorted(data.keys())
            except TypeError:
                tmp_keys = data.keys()
            for key in tmp_keys:
                print(key)
                if args.verbose:
                    print(' >>> {}'.format(data[key]))
                else:
                    print('  type   : {}'.format(type(data[key]).__name__))
                    if hasattr(data[key], '__len__'):
                        print('  length : {}'.format(len(data[key])))
    else:
        print(data)


def main_numpy(fpath, args):
    import numpy as np
    from numpy.lib.npyio import NpzFile
    def show_numpy(data):
        # shape
        shape = data.shape
        print('shape    : {}'.format(shape))
        if np.prod(shape)==0:
            print('  empty data.')
            return
        # other information
        try:
            if np.any(np.isnan(data)):
                # including np.nan
                try: d_mean = np.nanmean(data)
                except Exception as e: d_mean = '{}: {}'.format(str(type(e)).split("'")[1], e)
                try: d_max = np.nanmax(data)
                except Exception as e: d_max = '{}: {}'.format(str(type(e)).split("'")[1], e)
                try: d_min = np.nanmin(data)
                except Exception as e: d_min = '{}: {}'.format(str(type(e)).split("'")[1], e)
                try:
                    nan_rate = np.sum(np.isnan(data))/np.prod(data.shape)
                except Exception as e:
                    nan_rate = '{}: {}'.format(str(type(e)).split("'")[1], e)
                prt_str = '''mean     : {}
max      : {}
min      : {}
nan rate : {:.1f}%'''.format(d_mean, d_max, d_min, 100*nan_rate)
            else:
                # normal data
                try: d_mean = np.mean(data)
                except Exception as e: d_mean = '{}: {}'.format(str(type(e)).split("'")[1], e)
                try: d_max = np.max(data)
                except Exception as e: d_max = '{}: {}'.format(str(type(e)).split("'")[1], e)
                try: d_min = np.min(data)
                except Exception as e: d_min = '{}: {}'.format(str(type(e)).split("'")[1], e)
                prt_str = '''mean     : {}
max      : {}
min      : {}'''.format(d_mean, d_max, d_min)
        except TypeError as e:
            # string list or something
            prt_str = 'not a array of number'
        print(prt_str)

    data = np.load(fpath)
    if args_chk(args, 'verbose'):
        if type(data) == NpzFile:
            for k in data:
                print_key(k)
                print(data[k])
        else:
            print(data)
    elif args_chk(args, 'key'):
        if type(data) == NpzFile:
            if len(args.key)==0:
                for k in data:
                    print(k)
            for k in args.key:
                print_key(k)
                print(data[k])
                show_numpy(data[k])
                print()
    else:
        if type(data) == NpzFile:
            for k in data:
                print('\n{}'.format(k))
                show_numpy(data[k])
        else:
            show_numpy(data)

def main_tar(fpath, args):
    if not available_libtree:
        cprint('libtree is not available. exit.', fg='r', file=sys.stderr)
        return
    img_viewer = get_image_viewer(args)
    if img_viewer == 'matplotlib':
        import tempfile
    elif img_viewer == 'OpenCV':
        import tempfile
    else:
        import tempfile
        import subprocess

    if not tarfile.is_tarfile(fpath):
        print('{} is not a tar file.'.format(fpath))
        return
    tar_file = tarfile.open(fpath, 'r:*')
    list_tree = [{}]
    fname = os.path.basename(fpath)

    def show_tar(cpath):
        # check cpath
        try:
            if cpath.endswith('/'):
                key_name = cpath[:-1]
            else:
                key_name = cpath
            tarinfo = tar_file.getmember(key_name)
        except KeyError as e:
            print('Error!! Cannot open {}.'.format(cpath), file=sys.stderr)
            return

        # file
        if tarinfo.isfile():

            # image file
            if is_image(cpath):
                if img_viewer is None:
                    print('There are no way to show image.')
                elif img_viewer == 'PIL':
                    with Image.open(tar_file.extractfile(cpath)) as img:
                        img.show(title=os.path.basename(cpath))
                elif img_viewer == 'matplotlib':
                    with tempfile.TemporaryDirectory() as tmpdir:
                        tar_file.extractall(path=tmpdir, members=[tarinfo])
                        tmpfile = os.path.join(tmpdir, cpath)
                        img = plt.imread(tmpfile)
                    fig1 = plt.figure()
                    ax11 = fig1.add_axes((0, 0, 1, 1))
                    ax11.imshow(img)
                    # not display axes
                    ax11.xaxis.set_visible(False)
                    ax11.yaxis.set_visible(False)
                    ax11.spines['top'].set_visible(False)
                    ax11.spines['bottom'].set_visible(False)
                    ax11.spines['right'].set_visible(False)
                    ax11.spines['left'].set_visible(False)
                    plt.show()
                elif img_viewer == 'OpenCV':
                    with tempfile.TemporaryDirectory() as tmpdir:
                        tar_file.extractall(path=tmpdir, members=[tarinfo])
                        tmpfile = os.path.join(tmpdir, cpath)
                        img = cv2.imread(tmpfile)
                    cv2.imshow(os.path.basename(cpath), img)
                    cv2.waitKey(0)
                    # cv2.destroyAllWindows()
                else:
                    with tempfile.TemporaryDirectory() as tmpdir:
                        tar_file.extractall(path=tmpdir, members=[tarinfo])
                        tmpfile = os.path.join(tmpdir, cpath)
                        cmds = get_exec_cmds(args, tmpfile)
                        subprocess.run(cmds)
                        # wait to open file. this is for, e.g., open command on Mac OS.
                        input('Press Enter to continue')

            # text file?
            else:
                for line in tar_file.extractfile(cpath):
                    try:
                        print(line.decode(), end='')
                    except UnicodeDecodeError as e:
                        print('Error!! {}'.format(e), file=sys.stderr)
                        return
            print('')

        #directory
        elif tarinfo.isdir():
            tree = tree_viewer(list_tree, fname)
            print('{}/'.format(key_name))
            files, dirs = tree.get_contents(key_name)
            for f in files:
                print('{}{}'.format(branch_str, f))
            for d in dirs:
                print('{}{}/'.format(branch_str, d))
        else:
            cprint('sorry, I can\'t show information.\n', '', fg='r')

    # make list_tree
    for t in tar_file:
        tmp_list = list_tree
        depth = 1
        tnames = t.name.split('/')
        if debug: print('cpath: {}'.format(t.name))
        for p in tnames:
            if p == '': continue
            if t.isfile() and depth==len(tnames):
                # file
                tmp_list.append(p)
                if debug:
                    print('add {} to {} @ {:d}'.format(p, tmp_list, depth))
            elif p in tmp_list[0]:
                # existing directory
                tmp_list = tmp_list[0][p]
                depth += 1
            else:
                # new directory
                tmp_list[0][p] = [{}]
                tmp_list = tmp_list[0][p]
                depth += 1
    if debug:
        print(list_tree)

    if args_chk(args, 'interactive'):
        interactive_view(list_tree, fname, show_tar)
    elif args_chk(args, 'key'):
        if len(args.key)==0:
            tar_file.list(verbose=False)
        for k in args.key:
            print_key(k)
            show_tar(k)
            print()
    elif args_chk(args, 'verbose'):
        tar_file.list(verbose=True)
    else:
        show_tree(list_tree, fname)

    tar_file.close()

def main_zip(fpath, args):
    if not available_libtree:
        cprint('libtree is not available. exit.', fg='r', file=sys.stderr)
        return
    import zipfile
    img_viewer = get_image_viewer(args)
    if img_viewer == 'PIL':
        import io
    elif img_viewer == 'matplotlib':
        import tempfile
    elif img_viewer == 'OpenCV':
        import tempfile
    else:
        import tempfile
        import subprocess

    if not zipfile.is_zipfile(fpath):
        print('{} is not a zip file.'.format(fpath))
        return
    zip_file = zipfile.ZipFile(fpath, 'r')
    list_tree = [{}]
    fname = os.path.basename(fpath)

    def show_zip(cpath):
        try:
            key_name = cpath
            if key_name+'/' in zip_file.namelist():
                key_name += '/'
            zipinfo = zip_file.getinfo(key_name)
        except KeyError as e:
            if debug:
                print(e)
            print('Error!! cannnot open {}.'.format(cpath), file=sys.stderr)
            return

        # directory
        if zipinfo.is_dir():
            tree = tree_viewer(list_tree, fname)
            print('{}/'.format(key_name))
            files, dirs = tree.get_contents(key_name)
            for f in files:
                print('{}{}'.format(branch_str, f))
            for d in dirs:
                print('{}{}/'.format(branch_str, d))

        # file
        else:
            if is_image(cpath):
                if img_viewer is None:
                    print('There are no way to show image.')
                elif img_viewer == 'PIL':
                    with Image.open(io.BytesIO(zip_file.read(cpath))) as img:
                        img.show(title=os.path.basename(cpath))
                elif img_viewer == 'matplotlib':
                    with tempfile.TemporaryDirectory() as tmpdir:
                        zip_file.extract(zipinfo, path=tmpdir)
                        tmpfile = os.path.join(tmpdir, cpath)
                        img = plt.imread(tmpfile)
                    fig1 = plt.figure()
                    ax11 = fig1.add_axes((0, 0, 1, 1))
                    ax11.imshow(img)
                    # not display axes
                    ax11.xaxis.set_visible(False)
                    ax11.yaxis.set_visible(False)
                    ax11.spines['top'].set_visible(False)
                    ax11.spines['bottom'].set_visible(False)
                    ax11.spines['right'].set_visible(False)
                    ax11.spines['left'].set_visible(False)
                    plt.show()
                elif img_viewer == 'OpenCV':
                    with tempfile.TemporaryDirectory() as tmpdir:
                        zip_file.extract(zipinfo, path=tmpdir)
                        tmpfile = os.path.join(tmpdir, cpath)
                        img = cv2.imread(tmpfile)
                    cv2.imshow(os.path.basename(cpath), img)
                    cv2.waitKey(0)
                    # cv2.destroyAllWindows()
                else:
                    with tempfile.TemporaryDirectory() as tmpdir:
                        zip_file.extract(zipinfo, path=tmpdir)
                        tmpfile = os.path.join(tmpdir, cpath)
                        cmds = get_exec_cmds(args, tmpfile)
                        subprocess.run(cmds)
                        # wait to open file. this is for, e.g., open command on Mac OS.
                        input('Press Enter to continue')

            # text file?
            else:
                for line in zip_file.open(cpath, 'r'):
                    try:
                        print(line.decode(), end='')
                    except UnicodeDecodeError as e:
                        print('Error!! {}'.format(e), file=sys.stderr)
                        return

    # make list_tree
    if args_chk(args, 'encoding'):
        zip_codec = args.encoding
    elif uname == 'Windows':
        zip_codec = 'cp932' # test codec.
    else:
        zip_codec = 'cp437' # test codec.
    for z in zip_file.infolist():
        tmp_list = list_tree
        depth = 1
        znames = z.filename.split('/')
        if debug: print('cpath: {}'.format(z.filename))
        for p in znames:
            try:
                # try to decode
                p = p.encode(zip_codec, 'replace').decode()
            except Exception as e:
                if debug:
                    print(e)
            if p == '': continue
            if (not z.is_dir()) and depth==len(znames):
                # file
                tmp_list.append(p)
                if debug:
                    print('add {} to {} @ {:d}'.format(p, tmp_list, depth))
            elif p in tmp_list[0]:
                # existing directory
                tmp_list = tmp_list[0][p]
                depth += 1
            else:
                tmp_list[0][p] = [{}]
                tmp_list = tmp_list[0][p]
                depth += 1
    if debug:
        print()
        print(list_tree)

    if args_chk(args, 'interactive'):
        interactive_view(list_tree, fname, show_zip)
    elif args_chk(args, 'key'):
        if len(args.key)==0:
            for fy in zip_file.namelist():
                print(fy)
        for k in args.key:
            print_key(k)
            show_zip(k)
            print()
    elif args_chk(args, 'verbose'):
        zip_file.printdir()
    else:
        show_tree(list_tree, fname)

    zip_file.close()

def main_sqlite3(fpath, args):
    import sqlite3
    try:
        from tabulate import tabulate
    except ImportError:
        print("I can't find tabulate library.")
        is_tabulate = False
    else:
        is_tabulate = True
    shift = '  '

    def show_table(table_path, verbose=True):
        if '/' in table_path:
            table, column = table_path.split('/')
            if column == '':
                column = None
            if debug:
                print('table, column: {}, {}'.format(table, column))
        else:
            table = table_path
            column = None
            if debug:
                print('table: {}'.format(table))
        cursor.execute("pragma table_info('{}')".format(table))
        table_info = cursor.fetchall()

        print(table)
        if not verbose:
            for tinfo in table_info:
                if tinfo[2] == '':
                    ctype = 'none'
                else:
                    ctype = tinfo[2]
                print('{}{} [ {} ]'.format(branch_str, tinfo[1], ctype))

        else:
            if column is None:
                headers = []
                for tinfo in table_info:
                    headers.append(tinfo[1])
                cursor.execute('select * from {}'.format(table))
            else:
                headers = column.split(',')
                cursor.execute('select {} from {}'.format(column, table))
            columns = cursor.fetchall()
            table = []
            for col in columns:
                table.append([])
                for item in col:
                    table[-1].append(item)

            if is_tabulate:
                table_str = tabulate(table, headers, tablefmt='orgtbl')
                table_str = table_str.replace('\n', '\n'+shift)
                print(shift + table_str)
            else:
                print(shift+'|', end='')
                for hd in headers:
                    print(' {} |'.format(hd), end='')
                print('')
                for itms in table:
                    print(shift+'|', end='')
                    for itm in itms:
                        print(' {} |'.format(itm), end='')
                    print('')

    database = sqlite3.connect(fpath)
    cursor = database.cursor()
    cursor.execute("select name from sqlite_master where type='table'")
    tables = cursor.fetchall()

    if args_chk(args, 'interactive'):
        # make list_tree
        list_tree = [{}]
        for table, in tables:
            if debug:
                print(table)
            list_tree[0][table] = [{}]
            cursor.execute("pragma table_info('{}')".format(table))
            table_info = cursor.fetchall()
            for tinfo in table_info:
                if debug:
                    print(tinfo)
                name = tinfo[1]
                list_tree[0][table].append(name)
        if debug:
            print(list_tree)
        fname = os.path.basename(fpath)
        interactive_view(list_tree, fname, show_table)
    elif args_chk(args, 'key'):
        if len(args.key)==0:
            for t in tables:
                print(t[0])
        for k in args.key:
            print_key(k)
            show_table(k, verbose=True)
            print()
    else:
        for table, in tables:
            show_table(table, args.verbose)

def main_raw(fpath, args):
    try:
        import rawpy
    except ImportError:
        print("I can't find rawpy.")
        return

    img_viewer = get_image_viewer(args)
    if img_viewer is None:
        print("I can't find any libraries to show image. Please install Pillow or matplotlib.")
        return
    elif img_viewer not in 'PIL matplotlib OpenCV'.split(' '):
        import tempfile
        import subprocess

    try:
        from screeninfo import get_monitors
    except ImportError:
        get_screen = False
    else:
        get_screen = True

    with rawpy.imread(fpath) as raw:
        rgb = raw.postprocess(demosaic_algorithm=rawpy.DemosaicAlgorithm.LINEAR)

    if debug:
        print(rgb.shape)
        print('use {}'.format(img_viewer))
    if img_viewer == 'PIL':
        img = Image.fromarray(rgb)
        img.show(title=os.path.basename(fpath))
    elif img_viewer == 'matplotlib':
        if get_screen:
            height = get_monitors()[0].height
        else:
            height = 1080   # assume a full-HD display
        rate = rgb.shape[0]/height*100
        h = int(rgb.shape[0]/rate)
        w = int(rgb.shape[1]/rate)
        fig1 = plt.figure(figsize=(w,h))
        # full display
        ax1 = fig1.add_axes((0, 0, 1, 1))
        ax1.imshow(rgb)
        # not display axes
        ax1.xaxis.set_visible(False)
        ax1.yaxis.set_visible(False)
        ax1.spines['top'].set_visible(False)
        ax1.spines['bottom'].set_visible(False)
        ax1.spines['right'].set_visible(False)
        ax1.spines['left'].set_visible(False)
        plt.show()
    elif img_viewer == 'OpenCV':
        img = rgb[:,:,::-1] # RGB -> BGR
        cv2.imshow(os.path.basename(fpath), img)
        cv2.waitKey(0)
        # cv2.destroyAllWindows()
    else:
        with tempfile.NamedTemporaryFile(suffix='.bmp') as tmp:
            make_bitmap(tmp.name, rgb)
            cmds = get_exec_cmds(args, tmp.name)
            subprocess.run(cmds)
            # wait to open file. this is for, e.g., open command on Mac OS.
            input('Press Enter to continue')

def main_jupyter(fpath, args):
    import json
    import base64

    img_viewer = get_image_viewer(args)
    if img_viewer == 'PIL':
        import io
    elif img_viewer == 'matplotlib':
        import tempfile
    elif img_viewer == 'OpenCV':
        import tempfile
    else:
        import tempfile
        import subprocess
        import time

    with open(fpath, 'r') as f:
        data = json.load(f)
    if debug:
        print('keys: {}'.format(data.keys()))

    if args_chk(args, 'verbose'):
        meta = data['metadata']
        if debug: print(meta)
        print('kernel   : {}'.format(meta['kernelspec']['display_name']))
        if 'language_info' in meta:
            print('language : {}-{}'.format( \
                    meta['language_info']['name'], \
                    meta['language_info']['version']))
        if 'colab' in meta:
            print('colab : {}'.format(meta['colab']['name']))

    tmp_images = []
    for cell in data['cells']:
        if debug:
            print(' ---- cell ----')
            print(cell)
            print('---------------')
        if cell['cell_type'] == 'code':
            cnt = cell['execution_count']
            if cnt is None:
                cnt = ' '
            # Input
            cprint('In [{}]'.format(cnt), fg='c')
            for instr in cell['source']:
                print(instr, end='')
            print()
            # Output
            if len(cell['outputs']) != 0:
                cprint('Out [{}]'.format(cnt), fg='r')
            for output in cell['outputs']:
                if 'text' in output:
                    for text in output['text']:
                        print(text, end='')
                    print()
                elif 'data' in output:
                    out_data = output['data']
                    for out_type in out_data:
                        if out_type == 'text/plain':
                            for text in out_data['text/plain']:
                                print(text, end='')
                            print()
                        elif out_type == 'image/png':
                            if img_viewer is None:
                                continue
                            img_code = out_data['image/png']
                            img_bin = base64.b64decode(img_code.encode())
                            if img_viewer == 'PIL':
                                with Image.open(io.BytesIO(img_bin)) as img:
                                    # title doesn't work?
                                    img.show(title='Out [{}]'.format(cnt))
                            elif img_viewer == 'matplotlib':
                                with tempfile.NamedTemporaryFile(suffix='.png') as tmp:
                                    tmp.write(img_bin)
                                    img = plt.imread(tmp.name)
                                fig1 = plt.figure()
                                ax11 = fig1.add_axes((0, 0, 1, 1))
                                ax11.imshow(img)
                                # not display axes
                                ax11.xaxis.set_visible(False)
                                ax11.yaxis.set_visible(False)
                                ax11.spines['top'].set_visible(False)
                                ax11.spines['bottom'].set_visible(False)
                                ax11.spines['right'].set_visible(False)
                                ax11.spines['left'].set_visible(False)
                                plt.show()
                            elif img_viewer == 'OpenCV':
                                with tempfile.NamedTemporaryFile(suffix='.png') as tmp:
                                    tmp.write(img_bin)
                                    img = cv2.imread(tmp.name)
                                cv2.imshow('Out [{}]'.format(cnt), img)
                                cv2.waitKey(500)
                            else:
                                tmp = tempfile.NamedTemporaryFile(suffix='.png')
                                tmp_images.append(tmp)
                                tmp.write(img_bin)
                                cmds = get_exec_cmds(args, tmp.name)
                                subprocess.run(cmds)
                                if args_chk(args, 'verbose'):
                                    time.sleep(1.)

        elif cell['cell_type'] == 'markdown':
            cprint('markdown', fg='g')
            for instr in cell['source']:
                print(instr, end='')
            print()

        elif cell['cell_type'] == 'raw':
            cprint('raw', fg='g')
            for instr in cell['source']:
                print(instr, end='')
            print()

        else:
            if debug:
                print('not a supported type of cell: {}'.format(cell['cell_type']))

        if not args_chk(args, 'verbose'):
            input(' >>> Press ENTER to continue')

    # image closing
    for tmp in tmp_images:
        if debug: print('close {}'.format(tmp.name))
        tmp.close()
    if img_viewer == 'OpenCV':
        if args_chk(args, 'verbose'): cv2.waitKey(0)
        cv2.destroyAllWindows()

def main_xpm(fpath, args):
    try:
        from xpm_loader import XPMLoader
    except ImportError:
        if debug: print('global xpm_loader is not found. search __file__/../lib.')
        try:
            sys.path.append(op.join(op.dirname(__file__), '../lib'))
            from xpm_loader import XPMLoader
        except ImportError:
            print("I can't find xpm_loader.")
            return

    img_viewer = get_image_viewer(args)
    if img_viewer is None:
        print("I can't find any libraries to show image. Please install Pillow or matplotlib.")
        return
    elif img_viewer not in 'PIL matplotlib OpenCV'.split(' '):
        import tempfile
        import subprocess

    xpm = XPMLoader(fpath)
    xpm.xpm_to_ndarray()
    data = xpm.ndarray
    width = xpm.info['width']
    height = xpm.info['height']

    if debug:
        print(data.shape)
        print('use {}'.format(img_viewer))
    if img_viewer == 'PIL':
        img = Image.fromarray(data)
        img.show(title=os.path.basename(fpath))
    elif img_viewer == 'matplotlib':
        fig1 = plt.figure(figsize=(width/100, height/100))
        # full display
        ax1 = fig1.add_axes((0, 0, 1, 1))
        ax1.imshow(data)
        # not display axes
        ax1.xaxis.set_visible(False)
        ax1.yaxis.set_visible(False)
        ax1.spines['top'].set_visible(False)
        ax1.spines['bottom'].set_visible(False)
        ax1.spines['right'].set_visible(False)
        ax1.spines['left'].set_visible(False)
        plt.show()
    elif img_viewer == 'OpenCV':
        img = data[:,:,[2,1,0,3]] # RGBA -> BGRA
        cv2.imshow(os.path.basename(fpath), img)
        cv2.waitKey(0)
        # cv2.destroyAllWindows()
    else:
        with tempfile.NamedTemporaryFile(suffix='.bmp') as tmp:
            make_bitmap(tmp.name, data)
            cmds = get_exec_cmds(args, tmp.name)
            subprocess.run(cmds)
            # wait to open file. this is for, e.g., open command on Mac OS.
            input('Press Enter to continue')

def add_options(args):
    space_str = '<<space>>'
    for opt in args.opts:
        if opt == 'help':
            print('''
Currently available options;
help                show this help message and exit.
debug:True/False    enable/disable debug message.
encoding:enc_name   set encoding.
exec:exec_cmds      set executed commands for external image viewer. %c=>image_viewer, %s=>target_file
env:'A=val1 B=val2' add environmental values.''')
            return False
        elif ':' in opt:
            key, value = opt.split(':', maxsplit=1)
            if key == 'debug':
                global debug
                if value == 'True': debug = True
                elif value == 'False': debug = False
                if debug:
                    print('debug: True')
            elif key == 'encoding':
                args.encoding = value
                if debug:
                    print('set encoding={}'.args.encoding)
            elif key == 'exec':
                if space_str in value:
                    cprint('executed commands may not work as expected', fg='y', file=sys.stderr)
                value = value.replace('\ ', space_str)
                vals = value.split(' ')
                for i in range(len(vals)):
                    if space_str in vals[i]:
                        vals[i] = vals[i].replace(space_str, ' ')
                args.exec = vals
            elif key == 'env':
                for eq in value.split(' '):
                    if '=' in eq:
                        env, val = eq.split('=', maxsplit=1)
                        if debug:
                            print("add env:'{}', val:'{}'".format(env, val))
                        if env in os.environ:
                            os.environ[env] += val
                        else:
                            os.environ[env] = val
    return True

def main(args):

    fpath = os.path.expandvars(os.path.expanduser(args.file))
    if not os.path.exists(fpath):
        print("file doesn't exists!")
        return
    if os.path.isdir(fpath):
        print("{} is a directory.".format(fpath))
        return

    if not args_chk(args, 'type'):
        if use_magic:
            args.type = get_filetype_magic(fpath)
        else:
            args.type = get_filetype(fpath)

    if args.type == 'text':
        if ('LANG' in os.environ) and ('ja_JP' in os.environ['LANG']):
            print('vimでも使ってろ！')
        else:
            print("Why Don't you use vim???")
        return

    if args.type == 'hdf5':
        main_hdf5(fpath, args)
    elif args.type == 'pickle':
        main_pickle(fpath, args)
    elif args.type == 'numpy':
        main_numpy(fpath, args)
    elif args.type == 'tar':
        main_tar(fpath, args)
    elif args.type == 'zip':
        main_zip(fpath, args)
    elif args.type == 'sqlite3':
        main_sqlite3(fpath, args)
    elif args.type == 'raw_image':
        main_raw(fpath, args)
    elif args.type == 'jupyter':
        main_jupyter(fpath, args)
    elif args.type == 'xpm':
        main_xpm(fpath, args)
    else:
        print('this file is not supported.')

    return

if __name__ == "__main__":
    supported_type = 'hdf5, pickle, numpy, tar, zip, sqlite3, raw_image, jupyter, xpm'
    parser = argparse.ArgumentParser(description="show the constitution of a file. support file types ... {}".format(supported_type))
    parser.add_argument('file', help='input file')
    parser.add_argument('-t', '--type', dest='type', help='file type', choices=supported_type.split(', '))
    parser.add_argument('-iv', '--image_viewer', help="set image viewer. supported args are 'matplotlib' (use matplotlib.pyplot.imshow), 'PIL' (use PIL.Image.show), 'OpenCV' (use cv2.imshow), and other string is treated as an external command (e.g. gosr, open).")
    parser.add_argument('--opts', help="Other options. Usually, users don't need to use this option. You can set option by '--opts Option:Value Option2:Value2'.", nargs='+')
    ex_group = parser.add_mutually_exclusive_group()
    ex_group.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='show details')
    ex_group.add_argument('-k', '--key', dest='key', help='Dictionary key name in a pickle, path to a Group/Dataset in hdf5, a path to a file/dictionary in tar/zip, a table[/column[,column2...]] in sqlite3 or a key name in npz. If no key is specified, return the list of keys.', nargs='*')
    ex_group.add_argument('-i', '--interactive', dest='interactive', help='open a file with interactive mode. support pickle, hdf5, tar, zip, sqlite3.', action='store_true')
    args = parser.parse_args()

    if args_chk(args, 'opts'):
        if not add_options(args): sys.exit()
    main(args)

