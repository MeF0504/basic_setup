#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim: set filetype=python:

from __future__ import print_function

import os
import sys
import argparse
import tarfile

try:
    from color_test import BG, FG, END
    print_color = True
except ImportError:
    print_color = False

inter_str = "'q':quit, '..':go back 1 tree, key_name:select a key >> "

def cprint(str1, str2, fg=None, bg=None, **kwargs):
    print_str = str1
    if print_color:
        if fg is not None:
            print_str = FG[fg]+print_str
        if bg is not None:
            print_str = BG[bg]+print_str
        if (fg is not None) or (bg is not None):
            print_str += END
    print_str += str2
    print(print_str, **kwargs)

#function to show the constitution of hdf5 file.
def main_hdf5(fpath, args):
    import h5py
    def print_data(name, obj):
        if isinstance(obj, h5py.Dataset):
            print(name)
            if args.verbose:
                with h5py.File(args.file, 'r') as f:
                    print(" >>>  {}".format(f[name][()]))

    with h5py.File(fpath, 'r') as f:
        if hasattr(args, 'key') and args.key is not None:
            print(f[args.key][()])
        else:
            # https://qiita.com/skotaro/items/873507dc8f8f967bbc03
            f.visititems(print_data)

def main_pickle(fpath, args):
    import pickle
    try:
        with open(fpath, 'rb') as f:
            data = pickle.load(f)
    except UnicodeDecodeError:
        with open(fpath, 'rb') as f:
            data = pickle.load(f, encoding='latin1')

    if type(data) == type(dict()):
        if hasattr(args, 'key') and args.key is not None:
            for k in data:
                if str(k) == args.key:
                    print(data[k])
        elif hasattr(args, 'interactive') and args.interactive:
            selected_keys = []
            tmp_data = data
            while(True):
                key_strs = [str(k) for k in selected_keys]
                cpath = '{}/{}'.format(os.path.basename(fpath), '/'.join(key_strs))
                cprint('current path:', ' {}'.format(cpath), bg='c')
                cprint('contents in this dict:', ' ', bg='g', end='')
                try:
                    tmp_keys = sorted(tmp_data.keys())
                except TypeError:
                    tmp_keys = tmp_data.keys()
                for i,k in enumerate(tmp_keys):
                    # print('|{} {}\n (type:{})'.format(i, k, type(tmp_data[k]).__name__), end=' ')
                    print('{},'.format(k), end='  ')
                print('\n')
                key_name = input(inter_str)
                if key_name == 'q':
                    break
                elif key_name == '':
                    continue
                elif key_name == '..':
                    if len(selected_keys) >= 1:
                        selected_keys = selected_keys[:-1]
                        tmp_data = data
                        for sk in selected_keys:
                            tmp_data = tmp_data[sk]
                    else:
                        cprint('you are in root.', '', fg='r')
                else:
                    find_key = False
                    for k in tmp_data:
                        if str(k) == key_name:
                            find_key = True
                            if type(tmp_data[k]) == dict:
                                tmp_data = tmp_data[k]
                                selected_keys.append(k)
                            else:
                                cprint('output::', '\n{}\n'.format(tmp_data[k]), bg='r')
                    if not find_key:
                        cprint('"{}" is not a correct name'.format(key_name), '', fg='r')
        else:
            try:
                tmp_keys = sorted(data.keys())
            except TypeError:
                tmp_keys = data.keys()
            for key in tmp_keys:
                print(key)
                if args.verbose:
                    print(' >>> {}'.format(data[key]))
                else:
                    print('  type   : {}'.format(type(data[key]).__name__))
                    if hasattr(data[key], '__len__'):
                        print('  length : {}'.format(len(data[key])))
    else:
        print(data)

def main_numpy(fpath, args):
    import numpy as np
    data = np.load(fpath)
    if args.verbose:
        print(data)
    else:
        d_mean = np.mean(data)
        d_max = np.max(data)
        d_min = np.min(data)
        if np.isnan(d_mean):
            d_mean = np.nanmean(data)
            d_max = np.nanmax(data)
            d_min = np.nanmin(data)
            nan_rate = 1 - np.sum(data==data)/np.prod(data.shape)
        prt_str = '''
shape : {}
mean : {}
max : {}
min : {} '''.format(data.shape, d_mean, d_max, d_min)
        if 'nan_rate' in locals():
            prt_str += '\nnan rate : {:.1f}%'.format(nan_rate*100)

        print(prt_str)

def main_tar(fpath, args):
    if not tarfile.is_tarfile(fpath):
        print('{} is not a tar file.'.format(fpath))
        return
    with tarfile.open(fpath, 'r:*') as tar:
        if hasattr(args, 'key') and args.key is not None:
            try:
                tarinfo = tar.getmember(args.key)
            except KeyError as e:
                print('Error!! cannnot open {}.'.format(args.key), file=sys.stderr)
                return
            if tarinfo.isfile():
                for line in tar.extractfile(args.key):
                    try:
                        print(line.decode(), end='')
                    except UnicodeDecodeError as e:
                        print('Error!! {}'.format(e), file=sys.stderr)
                        return
                print('')
            elif tarinfo.isdir():
                for tfile in tar.getnames():
                    if tfile[:len(args.key)] == args.key:
                        print(tfile)
        else:
            tar.list(verbose=args.verbose)

def main_zip(fpath, args):
    import zipfile
    with zipfile.ZipFile(fpath, 'r') as zip_files:
        if hasattr(args, 'key') and args.key is not None:
            zpath = zipfile.Path(zip_files, args.key)
            if not zpath.exists():
                print('Error!! cannnot open {}.'.format(args.key), file=sys.stderr)
                return
            if zpath.is_file():
                for line in zip_files.open(args.key, 'r'):
                    try:
                        print(line.decode(), end='')
                    except UnicodeDecodeError as e:
                        print('Error!! {}'.format(e), file=sys.stderr)
                        return
            elif zpath.is_dir():
                for zfile in zip_files.namelist():
                    if zfile[:len(args.key)] == args.key:
                        print(zfile)
            else:
                print('{} is a unknown filetype.'.format(args.key))
        elif args.verbose:
            zip_files.printdir()
        else:
            for zfile in zip_files.namelist():
                print(zfile)

def main_sqlite3(fpath, args):
    import sqlite3
    try:
        from tabulate import tabulate
        is_tabulate = True
    except ImportError:
        print("I can't find tabulate library.")
        is_tabulate = False
    shift = '  '

    def table_info_simple(table):
        cursor.execute("pragma table_info('{}')".format(table))
        table_info = cursor.fetchall()
        for tinfo in table_info:
            if tinfo[2] == '':
                ctype = 'none'
            else:
                ctype = tinfo[2]
            print('  | {} [ {} ]'.format(tinfo[1], ctype))

    def table_info_verbose(table):
        cursor.execute("pragma table_info('{}')".format(table))
        table_info = cursor.fetchall()
        headers = []
        for tinfo in table_info:
            headers.append(tinfo[1])
        cursor.execute('select * from {}'.format(table))
        column = cursor.fetchall()
        table = []
        for clm in column:
            table.append([])
            for item in clm:
                table[-1].append(item)

        if is_tabulate:
            table_str = tabulate(table, headers, tablefmt='orgtbl')
            table_str = table_str.replace('\n', '\n'+shift)
            print(shift + table_str)
        else:
            print(shift+'|', end='')
            for hd in headers:
                print(' {} |'.format(hd), end='')
            print('')
            for itms in table:
                print(shift+'|', end='')
                for itm in itms:
                    print(' {} |'.format(itm), end='')
                print('')

    def table_iinfo_inter():
        keys = []
        for tb in tables:
            keys.append(tb[0])
        selected_keys = []
        while(True):
            key_strs = [str(k) for k in selected_keys]
            cpath = '{}/{}'.format(os.path.basename(fpath), '/'.join(key_strs))
            cprint('current path:', ' {}'.format(cpath), bg='c')
            cprint('contents in this dict:', ' ', bg='g', end='')
            for k in keys:
                print('{},'.format(k), end='  ')
            print('\n')
            key_name = input(inter_str)
            if key_name == 'q':
                break
            elif key_name == '':
                continue
            elif key_name == '..':
                if len(selected_keys) >= 1:
                    selected_keys = selected_keys[:-1]
                    keys = []
                    for tb in tables:
                        keys.append(tb[0])
                else:
                    cprint('you are in root.', '', fg='r')
            else:
                if key_name not in keys:
                    cprint('"{}" is not a correct name'.format(key_name), '', fg='r')
                    continue
                if len(selected_keys) == 0:     # select tables
                    selected_keys.append(key_name)
                    cursor.execute("pragma table_info('{}')".format(key_name))
                    table_info = cursor.fetchall()
                    keys = []
                    for tinfo in table_info:
                        keys.append(tinfo[1])
                elif len(selected_keys) == 1:   # select columns
                    cursor.execute('select {} from {}'.format(key_name, selected_keys[0]))
                    column = cursor.fetchall()
                    output = []
                    for clm in column:
                        output.append(clm[0])
                    cprint('output::', '\n{}\n'.format(output), bg='r')
                else:
                    cprint('"{}" is not a correct name'.format(key_name), '', fg='r')

    database = sqlite3.connect(fpath)
    cursor = database.cursor()
    cursor.execute("select name from sqlite_master where type='table'")
    tables = cursor.fetchall()
    if hasattr(args, 'interactive') and args.interactive:
        table_iinfo_inter()
        return
    elif hasattr(args, 'key') and args.key is not None:
        print(args.key)
        table_info_verbose(args.key)
        return
    for tb in tables:
        table = tb[0]
        print(table)
        if args.verbose:
            table_info_verbose(table)
        else:
            table_info_simple(table)
    database.close()

def main_raw(fpath, args):
    try:
        import rawpy
    except ImportError:
        print("I can't find rawpy.")
        return
    try:
        import matplotlib.pyplot as plt
    except ImportError:
        print("I can't find matplotlib.")
        return

    with rawpy.imread(fpath) as raw:
        rgb = raw.postprocess()

    # full display
    plt.axes((0,0,1,1))
    plt.imshow(rgb)
    # not display axes
    ax = plt.gca()
    ax.axes.xaxis.set_visible(False)
    ax.axes.yaxis.set_visible(False)
    plt.show()

def main(args):

    fpath = os.path.expanduser(args.file)
    if not os.path.exists(fpath):
        print("file doesn't exists!")
        return

    if not hasattr(args, 'type') or (args.type is None):
        ext = fpath[fpath.rfind('.')+1:].lower()
        if ext == 'hdf5':
            args.type = 'hdf5'
        elif ext == 'pkl' or ext == 'pickle':
            args.type = 'pickle'
        elif ext == 'npy':
            args.type = 'numpy'
        elif tarfile.is_tarfile(fpath):
            args.type = 'tar'
        elif ext == 'zip':
            args.type = 'zip'
        elif ext in 'db db3 sql sql3 sqlite sqlite3'.split(' '):
            args.type = 'sqlite3'
        elif ext in 'raw nef nrw cr3 cr2 crw tif arw'.split(' '):   # nikon, canon, sony
            args.type = 'raw_image'
        elif ext == 'py':
            if 'ja_JP' in os.environ['LANG']:
                print('vimでも使ってろ！')
            else:
                print("Why Don't you use vim???")
            return

    if args.type == 'hdf5':
        main_hdf5(fpath, args)
    elif args.type == 'pickle':
        main_pickle(fpath, args)
    elif args.type == 'numpy':
        main_numpy(fpath, args)
    elif args.type == 'tar':
        main_tar(fpath, args)
    elif args.type == 'zip':
        main_zip(fpath, args)
    elif args.type == 'sqlite3':
        main_sqlite3(fpath, args)
    elif args.type == 'raw_image':
        main_raw(fpath, args)
    else:
        print('this file is not supported.')

    return

if __name__ == "__main__":
    supported_type = 'hdf5 pickle numpy tar zip sqlite3 raw_image'
    parser = argparse.ArgumentParser(description="show the constitution of file. supported file types ... " + supported_type.replace(' ', ', '))
    parser.add_argument('file', help='imput hdf5 file')
    parser.add_argument('-v', dest='verbose', action='store_true', help='show details')
    parser.add_argument('-t', '--type', dest='type', help='file type', choices=supported_type.split(' '))
    parser.add_argument('-k', '--key', dest='key', help='dictionary key name in pickle, Dataset name in hdf5, file name in tar/zip, or table name in sqlite3.')
    parser.add_argument('-i', '--interactive', dest='interactive', help='(beta ver.) open a file with interactive mode. now only supports pickle.', action='store_true')
    args = parser.parse_args()

    main(args)

