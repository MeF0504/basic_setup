# hookについて -> https://qiita.com/delphinus/items/cd221a450fd23506e81a

# project内の関数検索
[[plugins]]
repo = 'MeF0504/mftags'
hook_add = '''
"" mftags{{{
let g:mftag_auto_close = 1
let g:mftag_dir_auto_set = 1
let g:mftag_lang_setting = {}
let g:mftag_lang_setting.c = {'syntax':'cdfgstu', 'func':'cdfgstu'}
let g:mftag_lang_setting.python = {'tag':'cfv'}
let g:mftag_popup_on=0
let g:mftag_exe_option = '-R --exclude="tmp/*"'

nnoremap <silent> <Leader>m :MFfunclist<CR>

"}}}
'''

# joke command
[[plugins]]
repo = 'MeF0504/sl.vim'

# Syntax 情報をpopupで表示
[[plugins]]
repo = 'MeF0504/vim-popsyntax'

# 単語に色を付ける
[[plugins]]
repo = 'MeF0504/vim-wordcolor'
hook_add = '''
" {{{
let g:word_color_mapping = '//'
if has('gui_running')
    let g:word_color_highlight = {
                \ 'bg': ['Maroon', 'Green', 'Olive', 'Navy', 'Purple', 'Teal', 'Silver', 'Grey', 'Red', 'Lime', 'Yellow', 'Blue', 'Fuchsia', 'Aqua', 'White'],
                \ 'fg': ['White', 'Black', 'Black', 'Black', 'Black', 'Black', 'Black', 'White', 'White', 'Black', 'Black', 'Black', 'Black', 'Black', 'Black'],
                \ }
else
    let g:word_color_highlight = {
                \ 'bg': [  1,   2,   3,   4,   5,   6,   7,   9,  10,  11,  12,  13,  14,  15],
                \ 'fg': [255, 233, 233, 233, 233, 233, 233, 255, 233, 233, 233, 233, 233, 233],
                \ }
endif

" }}}
'''

# neosnippet用のsnipets
[[plugins]]
repo = 'Shougo/neosnippet-snippets'

# コード実行plugin
[[plugins]]
repo = 'thinca/vim-quickrun'
hook_add = '''
"" vim-quick_run {{{
let g:quickrun_no_default_key_mappings = 1

" default configs {{{
let g:quickrun_config = get(g:, 'quickrun_config', {})  " 変数がなければ初期化
" show errors in quickfix window
let g:quickrun_config._ = {
    \ 'outputter' : 'error',
    \ 'outputter/multi/targets' : ['buffer', 'quickfix'],
    \ 'outputter/error/success' : 'buffer',
    \ 'outputter/error/error'   : 'multi',
    \ 'hook/time/enable'        : 1,
    \ }
if has('job')
    let g:quickrun_config._.runner = 'job'
    let s:quickrun_status = "%#StatusLine_CHK#%{quickrun#is_running()?'>...':''}%#StatusLine#"
    call meflib#basic#set_local_var('statusline',
                \ [meflib#basic#get_local_var('statusline',
                \ {'_':"%f%m%r%h%w%<%=%y\ %l/%L\ [%P]"}
                \ )['_']..s:quickrun_status], ['_'])
endif

" python
let g:quickrun_config.python = {
            \ 'command' : 'python3'
            \ }

" markdown
if has('mac')
    let s:cmd = 'open'
    let s:exe = '%c %s -a Google\ Chrome'
elseif has('win32') || has('win64')
    let s:cmd = 'start'
    let s:exe = '%c chrome %s'
else
    let s:cmd = 'firefox &'   " temporary
    let s:exe = '%c %s'
endif
let g:quickrun_config.markdown = {
            \ 'command' : s:cmd,
            \ 'exec' : s:exe
            \}

" tex
if has('mac')
    " macOSでlatex (ptex2pdf)を使う場合
    " https://texwiki.texjp.org/?quickrun
    if isdirectory('/Applications/Skim.app')
        let s:open_tex_pdf = 'open -a Skim '
    else
        let s:open_tex_pdf = 'open '
    endif
    let g:quickrun_config.tex = {
                \ 'command' : 'ptex2pdf',
                \ 'exec' : ['%c -l -u -ot "-synctex=1 -interaction=nonstopmode" %s -output-directory %s:h', s:open_tex_pdf.'%s:r.pdf']
                \ }
endif
" }}}

" wrapper functions {{{
" Anywhere SID.
function! s:SID_PREFIX() " tentative
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction
if empty(expand('<SID>'))
    let s:sid = s:SID_PREFIX()
else
    let s:sid = expand('<SID>')
endif

" markdown {{{
function! s:qrun_markdown() abort
    let q_config = {}
    let l:is_marp = 0
    for l:ln in getline(1, 5)
        if stridx(l:ln, 'marp') != -1
            let l:is_marp = 1
            break
        endif
    endfor
    if l:is_marp == 1
        " make prezantation by markdown [https://github.com/marp-team/marp-cli]
        if executable('marp') == 1
            let exec_cmd = 'marp'
            let exec_opt = ''
        else
            let exec_cmd = 'npx'
            let exec_opt = "\\\\\\@marp-team/marp-cli"
        endif
        let marp_theme_dir = get(g:, 'marp_dir', expand('$HOME/.marp'))
        if isdirectory(marp_theme_dir)
            let exec_opt .= ' --theme-set '.marp_theme_dir
        endif
        let q_config['command'] = exec_cmd

        if has('terminal') " || has('nvim')
            " http://chrome.half-moon.org/43.html
            if has('mac')
                let open_server = 'open -n -a Google\\ Chrome --args -incognito http://localhost:8080/'
            elseif has('win32') || has('win64')
                let open_server = '"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe" --new-window --incognito http://localhost:8080/'
            else
                let open_server = 'firefox http://localhost:8080/ &'
            endif

            let q_config['exec'] = [open_server, '%c '.exec_opt.' --server %s:h']
            let q_config['runner'] = 'terminal'
            let q_config['runner/opener'] = 'tabnew'
        else
            if has('mac')
                let open_pdf = 'open %s:r.pdf'
            elseif has('win32') || has('win64')
                let open_pdf = 'start %s:r.pdf'
            else    " Linux
                let open_pdf = 'xdg-open %s:r.pdf'
            endif

            let q_config['exec'] = ['%c '.exec_opt.' --pdf --allow-local-files', open_pdf]
        endif
    endif
    call quickrun#run(q_config)
endfunction
" }}}

" {{{ tex
if has('mac')
    function! s:qrun_tex() abort
        " fileの場所まで移動はQucickRunの後にcd出来なかったので断念
        " let cur_dir = getcwd()
        " cd %:h
        " texの中間ファイルはbuild dirに突っ込む
        let build_dir = expand('%:h').'/__build__'
        if !isdirectory(build_dir)
            call mkdir(build_dir, 'p')
        endif

        " main.texがあったらそっちをコンパイル
        if filereadable(expand('%:h').'/main.tex')
            let main_file = expand('%:h').'/main.tex'
            let pdf_file = fnamemodify(main_file, ':r').'.pdf'
            let build_pdf = build_dir.'/'.fnamemodify(pdf_file, ':t')
        else
            let main_file = expand('%')
            let pdf_file = expand('%:r').'.pdf'
            let build_pdf = build_dir.'/'.expand('%:t:r').'.pdf'
        endif
        " bibliography があり，かつ.bibがmain.texより新しければbibもコンパイル
        let cmp_bib = 0
        let bib_line = match(readfile(main_file), 'bibliography')
        if bib_line != -1
            let bra_idx = match(readfile(main_file)[bib_line+1], '{')
            let bib_file = readfile(main_file)[bib_line+1][bra_idx+1:-2].'.bib'
            if getftime(main_file) < getftime(bib_file)
                let cmp_bib = 1
            endif
        endif


        let q_config = {
            \ 'command': 'ptex2pdf',
            \ 'exec'   : [],
            \ }
        if cmp_bib == 1
            let q_config['exec'] += [
                \ 'uplatex -output-directory '.build_dir.' '.fnamemodify(main_file, ':r'),
                \ 'upbibtex '.build_dir.'/'.fnamemodify(main_file, ':r'),
                \ 'uplatex -output-directory '.build_dir.' '.fnamemodify(main_file, ':r'),
                \ ]
        endif
        let q_config['exec'] += [
            \ '%c -l -u -ot "-synctex=1 -interaction=nonstopmode" '.main_file.' -output-directory '.build_dir,
            \ 'mv '.build_pdf.' '.pdf_file,
            \ 'echo "\\n move from '.build_pdf.' to '.pdf_file.'"',
            \ s:open_tex_pdf.pdf_file,
            \ ]

        call quickrun#run(q_config)
    endfunction
endif
" }}}

function! <SID>quickrun_wrapper()
    if &modified
        echo 'file is not saved.'
        return
    endif
    if quickrun#is_running()
        echo 'quickrun is running'
        return
    endif
    cclose
    let qrun_ft_func = s:sid.'qrun_'.&filetype
    if exists('*'.qrun_ft_func)
        execute 'call '.qrun_ft_func.'()'
    else
        QuickRun
    endif
endfunction
" }}}

nnoremap <silent> <Leader>q :call <SID>quickrun_wrapper()<CR>
" }}}
'''

# 背景透過
[[plugins]]
repo = 'miyakogi/seiya.vim'
hook_add = '''
"" seiya.vim "{{{
"vimの背景を透過
let g:seiya_auto_enable=1
"}}}
'''

# 関数一覧を表示
[[plugins]]
# repo = 'vim-scripts/taglist.vim'
repo = 'yegappan/taglist'
hook_add = '''
"" taglist.vim "{{{
let g:Tlist_Exit_OnlyWindow = 1
let g:Tlist_Show_One_File = 1
let g:Tlist_File_Fold_Auto_Close = 1
" 幅の設定
" gui offのときは自動で幅が変わらないようにする (バグる)
if has('gui_running')
    let s:Max_WinWidth = 45
    let g:Tlist_Inc_Winwidth = 1
else
    let s:Max_WinWidth = 35
    let g:Tlist_Inc_Winwidth = 0
endif

"<space>をlocal用のmappingにする。
"nnoremap <silent> <Leader>t :Tlist<CR>

function! Open_taglist()
    if exists('g:Tlist_Use_Right_Window')
        let l:tlist_right_old = g:Tlist_Use_Right_Window
    else
        let l:tlist_right_old = 0
    endif
    " guiの時はいらないかも？↓
    if winwidth(winnr()) > s:Max_WinWidth*3
        let g:Tlist_WinWidth = s:Max_WinWidth
    else
        let g:Tlist_WinWidth = (winwidth(winnr())/16)*5
    endif

    " 右端だと右側に開く
    if (winnr()==1 ) || (winnr() != winnr("1l"))
        let g:Tlist_Use_Right_Window = 0
    else
        let g:Tlist_Use_Right_Window = 1
    endif

    " 右側で表示して閉じた際にwinnrが変わる問題対応
    let winnr = -1
    if &filetype != 'taglist'
        let winnr = winnr()
        if getbufvar(tabpagebuflist()[0], '&filetype') == 'taglist'
            let winnr -= 1
        endif
    endif

    TlistToggle

    " when tablist is closed
    if (getbufvar(tabpagebuflist()[0], '&filetype') != 'taglist') &&
        \ (getbufvar(tabpagebuflist()[-1], '&filetype') != 'taglist')
        if winnr != -1
            execute winnr . 'wincmd w'
        endif
    endif
    let g:Tlist_Use_Right_Window = l:tlist_right_old
endfunction
nnoremap <silent> <Leader>t :call Open_taglist()<CR>
"}}}
'''

# project内のファイル検索
[[plugins]]
repo = 'ctrlpvim/ctrlp.vim'
hook_add = '''
"" ctrlp{{{
"nnoremap <leader>s :<C-U>CtrlP<CR>
let g:ctrlp_map = '<leader>s'
let g:ctrlp_by_filename = 0
let g:ctrlp_match_window = 'order:ttb,min:1,max:7,results:15'
let g:ctrlp_switch_buffer = 'e'

let s:ctrlp_help_bufid = -1
let s:ctrlp_help_popid = -1
let s:ctrlp_help = [
        \ "<c-d>: Toggle between full-path search and filename only search.",
        \ "<c-r>: Toggle between the string mode and full regexp mode.",
        \ "<c-f>, <c-up>  : Scroll to the 'next' search mode in the sequence.",
        \ "<c-b>, <c-down>: Scroll to the 'previous' search mode in the sequence.",
        \ "<tab>: Auto-complete directory names under the current working directory inside the prompt.",
        \ "<s-tab>: Toggle the focus between the match window and the prompt.",
        \ "<esc>, <c-c>: Exit CtrlP.",
        \ "<c-a>: Move the cursor to the 'start' of the prompt.",
        \ "<c-e>: Move the cursor to the 'end' of the prompt.",
        \ "<c-w>: Delete a preceding inner word.",
        \ "<c-u>: Clear the input field.",
        \ "<c-n>: Next string in the prompt's history.",
        \ "<c-p>: Previous string in the prompt's history.",
        \ "<cr>:  Open the selected file in the 'current' window if possible.",
        \ "<c-t>: Open the selected file in a new 'tab'.",
        \ "<c-v>: Open the selected file in a 'vertical' split.",
        \ "<c-x>: Open the selected file in a 'horizontal' split.",
        \ "<c-y>: Create a new file and its parent directories.",
        \ ]
function! <SID>show_ctrlp_help()
    if s:ctrlp_help_popid != -1
        call meflib#floating#float_close(s:ctrlp_help_popid)
        let s:ctrlp_help_popid = -1
        return
    endif
    let config = {
        \ 'relative': 'editor',
        \ 'line': &lines-7-&cmdheight-2,
        \ 'col': &columns-3,
        \ 'pos': 'botright',
        \ }
    let [s:ctrlp_help_bufid, s:ctrlp_help_popid] = meflib#floating#float_wrapper(s:ctrlp_help_bufid, s:ctrlp_help_popid, s:ctrlp_help, config)
endfunction
autocmd deinLocal FileType ctrlp ++once nnoremap <buffer> <silent> ? :call <SID>show_ctrlp_help()<CR>
"}}}
'''

# current lineの関数表示用plugin (StatusLine用)
[[plugins]]
repo = 'tyru/current-func-info.vim'
hook_post_source = '''
"" current-func-info.vim {{{
let s:cfi_bufid = -1
let s:cfi_popid = -1
function! <SID>Show_cfi()
    if meflib#basic#get_local_var('cfi_on', 0) == 0
        call meflib#floating#float_close(s:cfi_popid)
        let s:cfi_popid = -1
        return
    endif
    if cfi#supported_filetype(&filetype) == 0
        return
    endif
    if has('nvim')
        let line = 0
    else
        let line = 1
    endif
    " let cfi = cfi#get_func_name()
    let cfi = cfi#format("%s()", "Top")
    let config = {
        \ 'relative': 'win',
        \ 'line': line,
        \ 'col': winwidth(0),
        \ 'pos': 'topright',
        \ 'highlight': 'CFIPopup',
        \ }
    let [s:cfi_bufid, s:cfi_popid] = meflib#floating#float_wrapper(s:cfi_bufid, s:cfi_popid, [cfi], config)
endfunction
autocmd deinLocal CursorMoved * call <SID>Show_cfi()
autocmd deinLocal WinLeave * call meflib#floating#float_close(s:cfi_popid) | let s:cfi_popid=-1
autocmd deinLocal QuitPre * call meflib#floating#float_close(s:cfi_popid) | let s:cfi_popid=-1
" }}}
'''

# 検索時にhit数をcountしてくれるplugin
[[plugins]]
repo = 'osyo-manga/vim-anzu'
if = '''!(exists('*searchcount') && exists('*popup_create'))'''  # if exists => use vim-hitspop
hook_add = '''
"" vim-anzu {{{
if !(exists('*searchcount') && exists('*popup_create'))
    " max search count
    let g:anzu_search_limit = 3000
    " mapping
    nmap n <Plug>(anzu-n-with-echo)
    nmap N <Plug>(anzu-N-with-echo)

    " clear status
    " nmap <ESC><ESC> <Plug>(anzu-clear-search-status)
endif
" }}}
'''

# if - endif 等を補完してくれるplugin
[[plugins]]
repo = 'tpope/vim-endwise'
hook_add = '''
"" endwise {{{
autocmd deinLocal FileType html
        \ let b:endwise_addition = '\=submatch(0)=="html" ? "\</html\>" : submatch(0)=="head" ? "\</head\>" : submatch(0)=="body" ? "\</body\>" : submatch(0)=="script" ? "\</script\>" : "\</style\>"' |
        \ let b:endwise_words = 'html,head,body,script,style' |
        \ let b:endwise_syngroups = 'htmlTagName,htmlSpecialTagName'
" https://github.com/tpope/vim-endwise/issues/83
autocmd deinLocal FileType tex
        \ let b:endwise_addition = '\="\\end" . matchstr(submatch(0), "{.\\{-}}")' |
        \ let b:endwise_words = 'begin' |
        \ let b:endwise_pattern = '\\begin{.\{-}}' |
        \ let b:endwise_syngroups = 'texSection,texBeginEnd,texBeginEndName,texStatement'
"}}}
'''

# vim の document
[[plugins]]
repo = 'vim-jp/vimdoc-ja'
if = '''! has('nvim')'''
hook_add = '''
" {{{
" https://gorilla.netlify.app/articles/20190427-vim-help-jp.html
" helpを日本語優先にする
if !has('nvim')
    set helplang=ja
endif
" }}}
'''

# command line と検索時に補完してくれるplugin
[[plugins]]
repo = 'gelguy/wilder.nvim'
hook_post_source = '''
" {{{
" from https://github.com/gelguy/wilder.nvim
" call wilder#enable_cmdline_enter()

set wildcharm=<Tab>

" 検索時のみ補完する
call wilder#setup({
    \ 'enable_cmdline_enter': v:true,
    \ 'modes': ['/', '?'],
    \ 'next_key': '<Tab>',
    \ 'previous_key': '<S-Tab>',
    \ })
" }}}
'''

# for deoplete
# vim でneovim 用 pluginを動かすためのplugin
[[plugins]]
repo = 'roxma/nvim-yarp'
if = '''!has('nvim') && !has('patch-8.2.3081')'''

# for deoplete
# vim でneovim 用 pluginを動かすためのplugin
[[plugins]]
repo = 'roxma/vim-hug-neovim-rpc'
if = '''!has('nvim') && !has('patch-8.2.3081')'''

# visual modeで選択した範囲をgcでコメントアウトしてくれるplugin
[[plugins]]
repo = 'tpope/vim-commentary'

# 検索のhit数をpopupで表示するplugin
[[plugins]]
repo = 'obcat/vim-hitspop'
if = '''exists('*searchcount') && exists('*popup_create')'''   # if not exists => use vim-anzu
hook_add = '''
" {{{
if exists('*searchcount') && exists('*popup_create')
    " https://zenn.dev/obcat/articles/4ef6822de53b643bbd01
    " :nohlsearch で消える→ 自分は\で消える
    " 右下に表示
    let g:hitspop_line = 'winbot'
    let g:hitspop_column = 'winright'
endif
" }}}
'''

# 英語翻訳プラグイン
# https://qiita.com/gorilla0513/items/37c80569ff8f3a1c721c
[[plugins]]
repo = 'skanehira/translate.vim'
hook_add = '''
" {{{
let g:translate_popup_window = 0
let g:translate_source = 'en'
let g:translate_target = 'ja'
" }}}
'''

# カーソル下の変数と同じ変数に下線
[[plugins]]
repo = 'itchyny/vim-cursorword'
hook_add = '''
" {{{
" デフォルトのhighlightをoff
let g:cursorword_highlight = 0
highlight CursorWord1 ctermfg=None ctermbg=None cterm=None
highlight CursorWord0 ctermfg=None ctermbg=None cterm=underline
" }}}
'''

# An ecosystem of Vim/Neovim which allows developers to write plugins in Deno. だそうです
# for ddc.vim
[[plugins]]
repo = 'vim-denops/denops.vim'
if = '''executable('deno') && (has('patch-8.2.3081') || has('nvim-0.5.0'))'''

# Filer
[[plugins]]
repo = 'lambdalisue/fern.vim'
hook_add = '''
"" Fern {{{
" default keymap off
let g:fern#disable_default_mappings = 1
" 見た目の設定
let g:fern#renderer#default#root_symbol = '@ '
let g:fern#renderer#default#collapsed_symbol = '|= '
let g:fern#renderer#default#expanded_symbol = '|+ '
let g:fern#renderer#default#leaf_symbol = '|- '
let g:fern#keepalt_on_edit = 1

" Fern-local map
function! s:set_fern_map()
    nmap <buffer> <CR> <Plug>(fern-action-open-or-enter)
    " Enterでopen/expand/collapse
    nmap <buffer><expr>
            \ <Plug>(fern-my-open-or-expand-or-collapse)
            \ fern#smart#leaf(
            \   "<Plug>(fern-action-open:select)",
            \   "<Plug>(fern-action-expand)",
            \   "<Plug>(fern-action-collapse)",
            \ )
    nmap <buffer> <CR> <Plug>(fern-my-open-or-expand-or-collapse)
    " shift-→ でexpand
    nmap <buffer> <S-Right> <Plug>(fern-action-expand)
    " shift-← でcollapse
    nmap <buffer> <S-Left> <Plug>(fern-action-collapse)
    " shift-↑ でleave
    nmap <buffer> <S-Up> <Plug>(fern-action-leave)
    " shift-↓ でenter
    nmap <buffer> <S-Down> <Plug>(fern-action-enter)
    " <c-t> でtabで開く
    nmap <buffer> <c-t> <Plug>(fern-action-open:tabedit)
    " <c-g> でゴミ箱
    nmap <buffer> <c-g> <Plug>(fern-action-trash)
    " <c-s> でsystemで開く
    nmap <buffer> <c-s> <Plug>(fern-action-open:system)
    " <c-f> で検索
    nmap <buffer> <c-f> <Plug>(fern-action-search-ctrlp:cursor)
endfunction
autocmd deinLocal FileType fern call s:set_fern_map()

" host map
nnoremap <silent> <leader>n :Fern . -drawer -toggle -reveal=%<CR>

" 色設定
function! s:set_fern_hi()
    highlight FernMarkedText ctermfg=196 guifg=#ff0000
    highlight FernRootSymbol ctermfg=11 guifg=#ffff00
    highlight FernRootText ctermfg=220 guifg=#d0d000
    highlight FernBranchSymbol ctermfg=10 guifg=#00ff00
    highlight FernBranchText ctermfg=2 guifg=#008000
    highlight FernLeafSymbol ctermfg=43 guifg=#00af5f
    " highlight FernLeafText ctermfg=41 guifg=#00d75f
endfunction
autocmd deinLocal User FernHighlight call s:set_fern_hi()
"" }}}
'''

# fern plugins {{{
[[plugins]]
repo = 'lambdalisue/fern-hijack.vim'
depends = ['fern.vim']

[[plugins]]
repo = 'lambdalisue/fern-ssh'
depends = ['fern.vim']

[[plugins]]
repo = 'lambdalisue/fern-mapping-project-top.vim'
depends = ['fern.vim']

[[plugins]]
repo = 'MeF0504/fern-mapping-search-ctrlp.vim'
depends = ['fern.vim', 'ctrlp.vim']
hook_add = '''
let g:fern_search_ctrlp_root = 1
let g:fern_search_ctrlp_open_file = 1
'''
# }}}

# tig 用 plugin
[[plugins]]
repo = 'iberianpig/tig-explorer.vim'
if = '''executable('tig')'''
hook_add = '''
"" tig-explorer {{{
command! TigDiff vertical TigOpenFileWithCommit! HEAD % 0
" }}}
'''

# required for tig-explorer
[[plugins]]
repo = 'rbgrouleff/bclose.vim'
if = '''executable('tig') && has('nvim')'''


