# hookについて -> https://qiita.com/delphinus/items/cd221a450fd23506e81a

# project内の関数検索
# [[plugins]]
# repo = 'MeF0504/mftags'
# hook_add = '''
# "" mftags{{{
# let g:mftag_auto_close = 1
# let g:mftag_dir_auto_set = 1
# let g:mftag_lang_setting = {}
# let g:mftag_lang_setting.c = {'syntax':'cdfgstu', 'func':'cdfgstu'}
# let g:mftag_lang_setting.python = {'tag':'cfv'}
# let g:mftag_popup_on=0
# let g:mftag_exe_option = '-R --exclude="tmp/*"'
# 
# nnoremap <silent> <Leader>m :MFfunclist<CR>
# 
# "}}}
# '''

# joke command
[[plugins]]
repo = 'MeF0504/sl.vim'

# Syntax 情報をpopupで表示
[[plugins]]
repo = 'MeF0504/vim-popsyntax'

# 単語に色を付ける
[[plugins]]
repo = 'MeF0504/vim-wordcolor'
hook_add = '''
"" wordcolor {{{
let g:word_color_mapping = '//'
" }}}
'''

# ctagsを使ってhighlightを設定 (mftags 分割 その1)
[[plugins]]
repo = 'MeF0504/highlightag.vim'
hook_add = '''
"" highlightag {{{
if has('nvim')
    " autocmd deinLocal VimEnter,BufWinEnter * silent call highlightag#run_hitag()
    autocmd deinLocal VimEnter,BufWinEnter * silent call highlightag#run_hitag_job_file()
else
    " autocmd deinLocal Syntax * silent call highlightag#run_hitag_job()
    autocmd deinLocal Syntax * silent call highlightag#run_hitag_job_file()
endif
" }}}
'''

# color codeに色を付ける
[[plugins]]
repo = 'MeF0504/hicolcode.vim'

# neosnippet用のsnipets
[[plugins]]
repo = 'Shougo/neosnippet-snippets'

# コード実行plugin
[[plugins]]
repo = 'thinca/vim-quickrun'
hook_add = '''
"" vim-quick_run {{{
let g:quickrun_no_default_key_mappings = 1

" default configs {{{
let g:quickrun_config = get(g:, 'quickrun_config', {})  " 変数がなければ初期化
" show errors in quickfix window
let g:quickrun_config._ = get(g:quickrun_config, '_', {})
call extend(g:quickrun_config._, {
    \ 'outputter' : 'error',
    \ 'outputter/multi/targets' : ['buffer', 'quickfix'],
    \ 'outputter/error/success' : 'buffer',
    \ 'outputter/error/error'   : 'multi',
    \ 'hook/time/enable'        : 1,
    \ },
    \ 'force')
if has('job')
    let g:quickrun_config._.runner = 'job'
    let s:quickrun_status = "%#StatusLine_CHK#%{quickrun#is_running()?'>...':''}%#StatusLine#"
    let s:cur_status = meflib#get_local_var('statusline', "%f%m%r%h%w%<%=%y\ %l/%L\ [%P]", '_')
    call meflib#set_local_var('statusline', s:cur_status..s:quickrun_status, '_')
endif

" python
let g:quickrun_config.python = {
            \ 'command' : 'python3'
            \ }

" markdown
if has('mac')
    let s:cmd = 'open'
    let s:exe = '%c %s -a Google\ Chrome'
elseif has('win32') || has('win64')
    let s:cmd = 'start'
    let s:exe = '%c chrome %s'
else
    let s:cmd = 'firefox &'   " temporary
    let s:exe = '%c %s'
endif
let g:quickrun_config.markdown = {
            \ 'command' : s:cmd,
            \ 'exec' : s:exe
            \}

" tex
if has('mac')
    " macOSでlatex (ptex2pdf)を使う場合
    " https://texwiki.texjp.org/?quickrun
    if isdirectory('/Applications/Skim.app')
        let s:open_tex_pdf = 'open -a Skim '
    else
        let s:open_tex_pdf = 'open '
    endif
    let g:quickrun_config.tex = {
                \ 'command' : 'ptex2pdf',
                \ 'exec' : ['%c -l -u -ot "-synctex=1 -interaction=nonstopmode" %s -output-directory %s:h', s:open_tex_pdf.'%s:r.pdf']
                \ }
endif
" }}}

" wrapper functions {{{
" Anywhere SID.
function! s:SID_PREFIX() " tentative
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction
if empty(expand('<SID>'))
    let s:sid = s:SID_PREFIX()
else
    let s:sid = expand('<SID>')
endif

" markdown {{{
function! s:qrun_markdown() abort
    let q_config = {}
    let l:is_marp = 0
    for l:ln in getline(1, 5)
        if stridx(l:ln, 'marp') != -1
            let l:is_marp = 1
            break
        endif
    endfor
    if l:is_marp == 1
        " make prezantation by markdown [https://github.com/marp-team/marp-cli]
        if executable('marp') == 1
            let exec_cmd = 'marp'
            let exec_opt = ''
        else
            let exec_cmd = 'npx'
            let exec_opt = "\\\\\\@marp-team/marp-cli"
        endif
        let marp_theme_dir = get(g:, 'marp_dir', expand('$HOME/.marp'))
        if isdirectory(marp_theme_dir)
            let exec_opt .= ' --theme-set '.marp_theme_dir
        endif
        let q_config['command'] = exec_cmd

        if has('terminal') || exists('s:quickrun_nvimterm')
            " http://chrome.half-moon.org/43.html
            if has('mac')
                let open_server = 'open -n -a Google\\ Chrome --args -incognito http://localhost:8080/'
            elseif has('win32') || has('win64')
                let open_server = '"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe" --new-window --incognito http://localhost:8080/'
            else
                let open_server = 'firefox http://localhost:8080/ &'
            endif

            let q_config['exec'] = [open_server, '%c '.exec_opt.' --server %s:h']
            if exists('s:quickrun_nvimterm')
                let q_config['runner'] = 'nvimterm'
            else
                let q_config['runner'] = 'terminal'
            endif
            let q_config['runner/opener'] = 'tabnew'
        else
            if has('mac')
                let open_pdf = 'open %s:r.pdf'
            elseif has('win32') || has('win64')
                let open_pdf = 'start %s:r.pdf'
            else    " Linux
                let open_pdf = 'xdg-open %s:r.pdf'
            endif

            let q_config['exec'] = ['%c '.exec_opt.' --pdf --allow-local-files', open_pdf]
        endif
    endif
    call quickrun#run(q_config)
endfunction
" }}}

" {{{ tex
if has('mac')
    function! s:qrun_tex() abort
        " fileの場所まで移動はQucickRunの後にcd出来なかったので断念
        " let cur_dir = getcwd()
        " cd %:h
        " texの中間ファイルはbuild dirに突っ込む
        let build_dir = expand('%:h').'/__build__'
        if !isdirectory(build_dir)
            call mkdir(build_dir, 'p')
        endif

        " main.texがあったらそっちをコンパイル
        if filereadable(expand('%:h').'/main.tex')
            let main_file = expand('%:h').'/main.tex'
            let pdf_file = fnamemodify(main_file, ':r').'.pdf'
            let build_pdf = build_dir.'/'.fnamemodify(pdf_file, ':t')
        else
            let main_file = expand('%')
            let pdf_file = expand('%:r').'.pdf'
            let build_pdf = build_dir.'/'.expand('%:t:r').'.pdf'
        endif
        " bibliography があり，かつ.bibがmain.texより新しければbibもコンパイル
        let cmp_bib = 0
        let bib_line = match(readfile(main_file), 'bibliography')
        if bib_line != -1
            let bra_idx = match(readfile(main_file)[bib_line+1], '{')
            let bib_file = readfile(main_file)[bib_line+1][bra_idx+1:-2].'.bib'
            if getftime(main_file) < getftime(bib_file)
                let cmp_bib = 1
            endif
        endif


        let q_config = {
            \ 'command': 'ptex2pdf',
            \ 'exec'   : [],
            \ }
        if cmp_bib == 1
            let q_config['exec'] += [
                \ 'uplatex -output-directory '.build_dir.' '.fnamemodify(main_file, ':r'),
                \ 'upbibtex '.build_dir.'/'.fnamemodify(main_file, ':r'),
                \ 'uplatex -output-directory '.build_dir.' '.fnamemodify(main_file, ':r'),
                \ ]
        endif
        let q_config['exec'] += [
            \ '%c -l -u -ot "-synctex=1 -interaction=nonstopmode" '.main_file.' -output-directory '.build_dir,
            \ 'mv '.build_pdf.' '.pdf_file,
            \ 'echo "\\n move from '.build_pdf.' to '.pdf_file.'"',
            \ s:open_tex_pdf.pdf_file,
            \ ]

        call quickrun#run(q_config)
    endfunction
endif
" }}}

function! <SID>quickrun_wrapper()
    if &modified
        echo 'file is not saved.'
        return
    endif
    if quickrun#is_running()
        echo 'quickrun is running'
        return
    endif
    cclose
    let qrun_ft_func = s:sid.'qrun_'.&filetype
    if exists('*'.qrun_ft_func)
        execute 'call '.qrun_ft_func.'()'
    else
        QuickRun
    endif
endfunction
" }}}

nnoremap <silent> <Leader>q :call <SID>quickrun_wrapper()<CR>
" }}}
'''

# job runner of quickrun for Neovim (unofficial)
[[plugins]]
repo = 'lambdalisue/vim-quickrun-neovim-job'
if = '''has('nvim')'''
hook_add = '''
"" vim-auickrun-neovim-job {{{
" 変数がなければ初期化
if has('nvim')
    let g:quickrun_config = get(g:, 'quickrun_config', {})
    let g:quickrun_config._ = get(g:quickrun_config, '_', {})
    let g:quickrun_config._.runner = 'neovim_job'
    let s:quickrun_status = "%#StatusLine_CHK#%{quickrun#is_running()?'>...':''}%#StatusLine#"
    let s:cur_status = meflib#get_local_var('statusline', "%f%m%r%h%w%<%=%y\ %l/%L\ [%P]", '_')
    call meflib#set_local_var('statusline', s:cur_status..s:quickrun_status, '_')
endif
" }}}
'''

# terminal runner of quickrun for Neovim (unofficial)
[[plugins]]
repo = 'statiolake/vim-quickrun-runner-nvimterm'
if = '''has('nvim')'''
hook_add = '''
"" vim-auickrun-runner-nvimterm {{{
" to check nvimterm is loaded
let s:quickrun_nvimterm = 1
" }}}
'''

# 背景透過
[[plugins]]
repo = 'miyakogi/seiya.vim'
hook_add = '''
"" seiya.vim "{{{
"vimの背景を透過
let g:seiya_auto_enable=1
if has('termguicolors') && !has('gui_running')
    let g:seiya_target_groups = ['ctermbg', 'guibg']
endif
"}}}
'''

# 関数一覧を表示
[[plugins]]
# repo = 'vim-scripts/taglist.vim'
repo = 'yegappan/taglist'
hook_add = '''
"" taglist.vim "{{{
let g:Tlist_Exit_OnlyWindow = 1
let g:Tlist_Show_One_File = 1
let g:Tlist_File_Fold_Auto_Close = 1
" 幅の設定
" gui offのときは自動で幅が変わらないようにする (バグる)
if has('gui_running')
    let s:Max_WinWidth = 45
    let g:Tlist_Inc_Winwidth = 1
else
    let s:Max_WinWidth = 35
    let g:Tlist_Inc_Winwidth = 0
endif

function! Open_taglist() abort
    " {{{
    if exists('g:Tlist_Use_Right_Window')
        let l:tlist_right_old = g:Tlist_Use_Right_Window
    else
        let l:tlist_right_old = 0
    endif
    " guiの時はいらないかも？↓
    if winwidth(winnr()) > s:Max_WinWidth*3
        let g:Tlist_WinWidth = s:Max_WinWidth
    else
        let g:Tlist_WinWidth = (winwidth(winnr())/16)*5
    endif

    " 右端だと右側に開く
    if (winnr()==1 ) || (winnr() != winnr("1l"))
        let g:Tlist_Use_Right_Window = 0
    else
        let g:Tlist_Use_Right_Window = 1
    endif

    " 右側で表示して閉じた際にwinnrが変わる問題対応
    let winnr = -1
    if &filetype != 'taglist'
        let winnr = winnr()
        if getbufvar(tabpagebuflist()[0], '&filetype') == 'taglist'
            let winnr -= 1
        endif
    endif

    TlistToggle

    " when tablist is closed
    if (getbufvar(tabpagebuflist()[0], '&filetype') != 'taglist') &&
        \ (getbufvar(tabpagebuflist()[-1], '&filetype') != 'taglist')
        if winnr != -1
            execute winnr . 'wincmd w'
        endif
    endif
    let g:Tlist_Use_Right_Window = l:tlist_right_old
    " }}}
endfunction
nnoremap <silent> <Leader>t :call Open_taglist()<CR>

function! s:tlist_all_comp(arglead, cmdline, cursorpos) abort
    " {{{
    ":h :command-completion-custom
    let arglead = tolower(a:arglead)
    let cmdline = tolower(a:cmdline)
    let cmd_args = split(cmdline, ' ', 1)
    if len(cmd_args) > 1+1
        " take only 1 argument. 1 is command itself ('tlistall').
        return []
    endif
    let opt_list = ['help', 'clear']
    return filter(opt_list, '!stridx(tolower(v:val), arglead)')
    " }}}
endfunction

function! s:tlist_all(...) abort
    " {{{
    if a:0 == 0
        let ext = ''
    elseif a:1 == 'help'
        echo ':TlistAll [args]'
        echo '    help  ... show this help.'
        echo '    clear ... delete session file.'
        echo '    else  ... specify extension. e.g. "*.py".'
        return
    else
        let ext = a:1
    endif
    let tlist_session_name = meflib#get_local_var('tlist_session_name', '.tlist_session')
    let cwd = meflib#basic#get_top_dir(expand('%:h'))
    if empty(cwd)
        let cwd = '.'
    endif
    let g:Tlist_Show_One_File = 0
    if filereadable(tlist_session_name)
        if ext == 'clear'
            call delete(tlist_session_name)
            return
        endif
        execute printf('TlistSessionLoad %s', tlist_session_name)
    else
        execute printf('TlistAddFilesRecursive %s %s', cwd, ext)
        execute printf('TlistSessionSave %s', tlist_session_name)
    endif
    TlistToggle
    " }}}
endfunction
command! -nargs=? -complete=customlist,s:tlist_all_comp TlistAll call s:tlist_all(<f-args>)
"}}}
'''

# project内のファイル検索
[[plugins]]
repo = 'ctrlpvim/ctrlp.vim'
hook_add = '''
"" ctrlp{{{
"nnoremap <leader>s :<C-U>CtrlP<CR>
let g:ctrlp_map = '<leader>s'
let g:ctrlp_by_filename = 0
let g:ctrlp_match_window = 'order:ttb,min:1,max:7,results:15'
let g:ctrlp_switch_buffer = 'e'

let s:ctrlp_help_bufid = -1
let s:ctrlp_help_popid = -1
let s:ctrlp_help = [
        \ "<c-d>: Toggle between full-path search and filename only search.",
        \ "<c-r>: Toggle between the string mode and full regexp mode.",
        \ "<c-f>, <c-up>  : Scroll to the 'next' search mode in the sequence.",
        \ "<c-b>, <c-down>: Scroll to the 'previous' search mode in the sequence.",
        \ "<tab>: Auto-complete directory names under the current working directory inside the prompt.",
        \ "<s-tab>: Toggle the focus between the match window and the prompt.",
        \ "<esc>, <c-c>: Exit CtrlP.",
        \ "<c-a>: Move the cursor to the 'start' of the prompt.",
        \ "<c-e>: Move the cursor to the 'end' of the prompt.",
        \ "<c-w>: Delete a preceding inner word.",
        \ "<c-u>: Clear the input field.",
        \ "<c-n>: Next string in the prompt's history.",
        \ "<c-p>: Previous string in the prompt's history.",
        \ "<cr>:  Open the selected file in the 'current' window if possible.",
        \ "<c-t>: Open the selected file in a new 'tab'.",
        \ "<c-v>: Open the selected file in a 'vertical' split.",
        \ "<c-x>: Open the selected file in a 'horizontal' split.",
        \ "<c-y>: Create a new file and its parent directories.",
        \ ]
function! <SID>show_ctrlp_help()
    if s:ctrlp_help_popid != -1
        call meflib#floating#close(s:ctrlp_help_popid)
        let s:ctrlp_help_popid = -1
        return
    endif
    let config = {
        \ 'relative': 'editor',
        \ 'line': &lines-7-&cmdheight-2,
        \ 'col': &columns-3,
        \ 'pos': 'botright',
        \ }
    let [s:ctrlp_help_bufid, s:ctrlp_help_popid] = meflib#floating#open(s:ctrlp_help_bufid, s:ctrlp_help_popid, s:ctrlp_help, config)
endfunction
autocmd deinLocal FileType ctrlp ++once nnoremap <buffer> <silent> ? :call <SID>show_ctrlp_help()<CR>
"}}}
'''

# current lineの関数表示用plugin (StatusLine用)
[[plugins]]
repo = 'tyru/current-func-info.vim'
hook_post_source = '''
"" current-func-info.vim {{{
let s:cfi_bufid = -1
let s:cfi_popid = -1
function! <SID>Show_cfi()
    if meflib#basic#get_local_var('cfi_on', 0) == 0
        call meflib#floating#close(s:cfi_popid)
        let s:cfi_popid = -1
        return
    endif
    if cfi#supported_filetype(&filetype) == 0
        return
    endif
    if has('nvim')
        let line = 0
    else
        let line = 1
    endif
    " let cfi = cfi#get_func_name()
    let cfi = cfi#format("%s()", "Top")
    let config = {
        \ 'relative': 'win',
        \ 'line': line,
        \ 'col': winwidth(0),
        \ 'pos': 'topright',
        \ 'highlight': 'CFIPopup',
        \ }
    let [s:cfi_bufid, s:cfi_popid] = meflib#floating#open(s:cfi_bufid, s:cfi_popid, [cfi], config)
endfunction
autocmd deinLocal CursorMoved * call <SID>Show_cfi()
autocmd deinLocal WinLeave * call meflib#floating#close(s:cfi_popid) | let s:cfi_popid=-1
autocmd deinLocal QuitPre * call meflib#floating#close(s:cfi_popid) | let s:cfi_popid=-1
" }}}
'''

# 検索時にhit数をcountしてくれるplugin
[[plugins]]
repo = 'osyo-manga/vim-anzu'
if = '''!(exists('*searchcount') && exists('*popup_create'))'''  # if exists => use vim-hitspop
hook_add = '''
"" vim-anzu {{{
if !(exists('*searchcount') && exists('*popup_create'))
    " max search count
    let g:anzu_search_limit = 3000
    " mapping
    nmap n <Plug>(anzu-n-with-echo)
    nmap N <Plug>(anzu-N-with-echo)

    " clear status
    " nmap <ESC><ESC> <Plug>(anzu-clear-search-status)
endif
" }}}
'''

# if - endif 等を補完してくれるplugin
[[plugins]]
repo = 'tpope/vim-endwise'
hook_add = '''
"" endwise {{{
autocmd deinLocal FileType html
        \ let b:endwise_addition = '\=submatch(0)=="html" ? "\</html\>" : submatch(0)=="head" ? "\</head\>" : submatch(0)=="body" ? "\</body\>" : submatch(0)=="script" ? "\</script\>" : "\</style\>"' |
        \ let b:endwise_words = 'html,head,body,script,style' |
        \ let b:endwise_syngroups = 'htmlTagName,htmlSpecialTagName'
" https://github.com/tpope/vim-endwise/issues/83
autocmd deinLocal FileType tex
        \ let b:endwise_addition = '\="\\end" . matchstr(submatch(0), "{.\\{-}}")' |
        \ let b:endwise_words = 'begin' |
        \ let b:endwise_pattern = '\\begin{.\{-}}' |
        \ let b:endwise_syngroups = 'texSection,texBeginEnd,texBeginEndName,texStatement'
"}}}
'''

# vim の document
[[plugins]]
repo = 'vim-jp/vimdoc-ja'
if = '''! has('nvim')'''
hook_add = '''
" {{{
" https://gorilla.netlify.app/articles/20190427-vim-help-jp.html
" helpを日本語優先にする
if !has('nvim')
    set helplang=ja
endif
" }}}
'''

# command line と検索時に補完してくれるplugin
[[plugins]]
repo = 'gelguy/wilder.nvim'
hook_post_source = '''
" {{{
" from https://github.com/gelguy/wilder.nvim
" call wilder#enable_cmdline_enter()

set wildcharm=<Tab>

" 検索時のみ補完する
call wilder#setup({
    \ 'enable_cmdline_enter': v:true,
    \ 'modes': ['/', '?'],
    \ 'next_key': '<Tab>',
    \ 'previous_key': '<S-Tab>',
    \ })
" }}}
'''

# for deoplete and wilder
# vim でneovim 用 pluginを動かすためのplugin
[[plugins]]
repo = 'roxma/nvim-yarp'
if = '''!has('nvim') '''# && !(executable('deno')&&has('patch-8.2.3081'))'''

# for deoplete and wilder
# vim でneovim 用 pluginを動かすためのplugin
[[plugins]]
repo = 'roxma/vim-hug-neovim-rpc'
if = '''!has('nvim') '''# && !(executable('deno')&&has('patch-8.2.3081'))'''

# visual modeで選択した範囲をgcでコメントアウトしてくれるplugin
[[plugins]]
repo = 'tpope/vim-commentary'

# 検索のhit数をpopupで表示するplugin
[[plugins]]
repo = 'obcat/vim-hitspop'
if = '''exists('*searchcount') && exists('*popup_create')'''   # if not exists => use vim-anzu
hook_add = '''
" {{{
if exists('*searchcount') && exists('*popup_create')
    " https://zenn.dev/obcat/articles/4ef6822de53b643bbd01
    " :nohlsearch で消える→ 自分は\で消える
    " 右下に表示
    let g:hitspop_line = 'winbot'
    let g:hitspop_column = 'winright'
endif
" }}}
'''

# 英語翻訳プラグイン
# https://qiita.com/gorilla0513/items/37c80569ff8f3a1c721c
[[plugins]]
repo = 'skanehira/translate.vim'
hook_add = '''
" {{{
let g:translate_popup_window = 0
let g:translate_source = 'en'
let g:translate_target = 'ja'
" }}}
'''

# カーソル下の変数と同じ変数に下線
[[plugins]]
repo = 'itchyny/vim-cursorword'
hook_add = '''
" {{{
" デフォルトのhighlightをoff
let g:cursorword_highlight = 0
highlight CursorWord1 ctermfg=None ctermbg=None cterm=None
highlight CursorWord0 ctermfg=None ctermbg=None cterm=underline
" }}}
'''

# An ecosystem of Vim/Neovim which allows developers to write plugins in Deno. だそうです
# for ddc.vim
[[plugins]]
repo = 'vim-denops/denops.vim'
if = '''executable('deno') && (has('patch-8.2.3081') || has('nvim-0.5.0'))'''

# denops test
[[plugins]]
repo = 'vim-denops/denops-helloworld.vim'
if = '''executable('deno') && (has('patch-8.2.3081') || has('nvim-0.5.0'))'''

# Filer
[[plugins]]
repo = 'lambdalisue/fern.vim'
hook_add = '''
"" Fern {{{
" default keymap off
let g:fern#disable_default_mappings = 1
" 見た目の設定
let g:fern#renderer#default#root_symbol = '@ '
let g:fern#renderer#default#collapsed_symbol = '|= '
let g:fern#renderer#default#expanded_symbol = '|+ '
let g:fern#renderer#default#leaf_symbol = '|- '
let g:fern#keepalt_on_edit = 1

" Fern-local map
function! s:set_fern_map()
    nmap <buffer> <CR> <Plug>(fern-action-open-or-enter)
    " Enterでopen/expand/collapse
    nmap <buffer><expr>
            \ <Plug>(fern-my-open-or-expand-or-collapse)
            \ fern#smart#leaf(
            \   "<Plug>(fern-action-open:select)",
            \   "<Plug>(fern-action-expand)",
            \   "<Plug>(fern-action-collapse)",
            \ )
    nmap <buffer> <CR> <Plug>(fern-my-open-or-expand-or-collapse)
    " shift-→ でexpand
    nmap <buffer> <S-Right> <Plug>(fern-action-expand)
    " shift-← でcollapse
    nmap <buffer> <S-Left> <Plug>(fern-action-collapse)
    " shift-↑ でleave
    nmap <buffer> <S-Up> <Plug>(fern-action-leave)
    " shift-↓ でenter
    nmap <buffer> <S-Down> <Plug>(fern-action-enter)
    " <c-t> でtabで開く
    nmap <buffer> <c-t> <Plug>(fern-action-open:tabedit)
    " <c-g> でゴミ箱
    nmap <buffer> <c-g> <Plug>(fern-action-trash)
    " <c-s> でsystemで開く
    nmap <buffer> <c-s> <Plug>(fern-action-open:system)
    " <c-f> で検索
    nmap <buffer> <c-f> <Plug>(fern-action-search-ctrlp:cursor)
endfunction
autocmd deinLocal FileType fern call s:set_fern_map()

" host map
nnoremap <silent> <leader>n :Fern . -drawer -toggle -reveal=%<CR>

" 色設定
function! s:set_fern_hi()
    highlight FernMarkedText ctermfg=196 guifg=#ff0000
    highlight FernRootSymbol ctermfg=11 guifg=#ffff00
    highlight FernRootText ctermfg=220 guifg=#d0d000
    highlight FernBranchSymbol ctermfg=10 guifg=#00ff00
    highlight FernBranchText ctermfg=2 guifg=#008000
    highlight FernLeafSymbol ctermfg=43 guifg=#00af5f
    " highlight FernLeafText ctermfg=41 guifg=#00d75f
endfunction
autocmd deinLocal User FernHighlight call s:set_fern_hi()
"" }}}
'''

# fern plugins {{{
[[plugins]]
repo = 'lambdalisue/fern-hijack.vim'
depends = ['fern.vim']

[[plugins]]
repo = 'lambdalisue/fern-ssh'
depends = ['fern.vim']
hook_add = '''
"" fern-ssh {{{
function! <SID>ssh_password() abort
    " https://qiita.com/wadahiro/items/977e4f820b4451a2e5e0
    " if !exists('s:pswd')
    let pswd = inputsecret('password: ')
    if !empty(pswd)
        let exec_cmd = ['echo '..pswd]
        let tmpfile = tempname()
        if has('win32') || has('win64')
            let tmpfile .= '.bat'
            call insert(exec_cmd, '@echo off')
        endif
        call writefile(exec_cmd, tmpfile, '')
        if executable('chmod')
            call system('chmod 700 '..tmpfile)
        endif
        let $SSH_ASKPASS = tmpfile
        if !exists('$DISPLAY')
            let $DISPLAY = 'dummy:0'
        endif
    endif
    " endif
endfunction
command! SetSshPass call <SID>ssh_password()
" }}}
'''

[[plugins]]
repo = 'lambdalisue/fern-mapping-project-top.vim'
depends = ['fern.vim']

[[plugins]]
repo = 'MeF0504/fern-mapping-search-ctrlp.vim'
depends = ['fern.vim', 'ctrlp.vim']
hook_add = '''
let g:fern_search_ctrlp_root = 1
let g:fern_search_ctrlp_open_file = 1
'''
# }}}

# tig 用 plugin
[[plugins]]
repo = 'iberianpig/tig-explorer.vim'
if = '''executable('tig')'''
hook_add = '''
"" tig-explorer {{{
command! TigDiff vertical TigOpenFileWithCommit! HEAD % 0
" }}}
'''

# required for tig-explorer
[[plugins]]
repo = 'rbgrouleff/bclose.vim'
if = '''executable('tig') && has('nvim')'''

# indent のlevelを見やすくする
[[plugins]]
repo = 'nathanaelkane/vim-indent-guides'
hook_add = '''
"" indent-guides {{{
" vim 起動時に起動
let g:indent_guides_enable_on_vim_startup = 1
" 色は自分で設定
let g:indent_guides_auto_colors = 0
" 2個目のindentから色をつける
let g:indent_guides_start_level = 2
" 1も自分だけ色つけ
let g:indent_guides_guide_size = 1
" mapは無し
let g:indent_guides_default_mapping = 0
" }}}
'''

