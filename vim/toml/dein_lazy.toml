
# toml 用 syntax
[[plugins]]
repo = 'cespare/vim-toml'
on_ft = 'toml'

# deinの設定ファイル内で，vimの部分をvimのsyntaxにする
[[plugins]]
repo = 'inkarkat/vim-SyntaxRange'
on_ft = 'toml'
hook_post_source = '''
" {{{
" https://qiita.com/tmsanrinsha/items/9670628aef3144c7919b
" Insertで戻る... 要検討 ... とりあえず:e!で再表示
function! s:syntax_range_dein() abort
    let start = '^\s*hook_\%('.
                \ 'add\|source\|post_source\|post_update'.
                \ '\)\s*=\s*%s'
    call SyntaxRange#Include(printf(start, "\'\'\'"), "\'\'\'", 'vim', '')
    call SyntaxRange#Include(printf(start, '"""'), '"""', 'vim', '')
endfunction

call s:syntax_range_dein()
" autocmdのタイミングが悪い (vim-tomlに上書きされる)ので，調整
" autocmd deinLocal BufNewFile,BufRead dein*.toml call s:syntax_range_dein()
autocmd deinLocal VimEnter,BufWinEnter dein*.toml call s:syntax_range_dein()
" }}}
'''

# 上のpluginで使われるやつ
[[plugins]]
repo = 'inkarkat/vim-ingo-library'
on_source = ['vim-SyntaxRange']

# vim でsnippet を使う用の plugin (framework?)
[[plugins]]
repo = 'Shougo/neosnippet.vim'
on_source = ['ddc.vim', 'deoplete.vim']

# vim script 用補完 plugin
[[plugins]]
repo = 'Shougo/neco-vim'
on_source = ['ddc.vim', 'deoplete.vim']
on_ft = 'vim'

# dark powered 補完plugin
[[plugins]]
repo = 'Shougo/deoplete.nvim'
if = '''has('python3') && (((v:version>=801)&&!has('patch-8.2.3081')) || (has('nvim')&&has('nvim-0.3.0')&&!has('nvim-0.5.0')))'''
on_event = 'InsertEnter'
hook_source = '''
"{{{ "deoplete
if has('python3') && ((v:version>=801) || (has('nvim')&&has('nvim-0.3.0')))
    let g:deoplete#enable_at_startup = 1
    inoremap <expr><tab> pumvisible() ? "\<C-n>" :
            \ neosnippet#expandable_or_jumpable() ?
            \    "\<Plug>(neosnippet_expand_or_jump)" : "\<tab>"
    inoremap <expr><S-tab> pumvisible() ? "\<C-p>" :
            \ neosnippet#expandable_or_jumpable() ?
            \    "\<Plug>(neosnippet_expand_or_jump)" : "\<S-tab>"

    """ test
    autocmd deinLocal FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd deinLocal FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd deinLocal FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd deinLocal FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd deinLocal FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    " auto close preview window.
    autocmd deinLocal CompleteDone * silent! pclose!
endif

"}}}
'''

### plugins for deoplete (from here) {{{
# https://github.com/Shougo/deoplete.nvim/wiki/Completion-Sources

# syntax file から補完候補を作成
[[plugins]]
repo = 'Shougo/neco-syntax'
on_source = ['deoplete.nvim']

# c言語用補完 plugin
[[plugins]]
repo = 'Shougo/deoplete-clangx'
on_source = ['deoplete.nvim']
on_ft = 'c'

# python 用補完 plugin
[[plugins]]
repo = 'deoplete-plugins/deoplete-jedi'
on_source = ['deoplete.nvim']
on_ft = 'python'

# zsh 用補完 plugin
[[plugins]]
repo = 'deoplete-plugins/deoplete-zsh'
on_source = ['deoplete.nvim']
on_ft = 'zsh'

### (to here) }}}

# vimの編集履歴を表示／適用してくれる plugin
[[plugins]]
repo = 'sjl/gundo.vim'
on_event = 'InsertEnter'
hook_source = '''
" {{{ "Gundo
if has('python3')
    let g:gundo_prefer_python3 = 1
endif
nnoremap <silent> <Leader>u :GundoToggle<CR>
" }}}
'''

# vimからJupyter notebookを開く
[[plugins]]
repo = 'jupyter-vim/jupyter-vim'
on_ft = 'python'
hook_source = '''
" {{{
" $ jupyter console --generate-config
" => c.ZMQTerminalInteractiveShell.include_other_output = True
" $ jupyter qtconsole --generate-config
" => c.ConsoleWidget.include_other_output = True

" no mapping
let g:jupyter_mapkeys = 0

let s:l_jupyter_connect = 0
let s:jupyter_arg_list_raw = 'Start Connect File Count Range Cell Code Cd Restart'
function! s:jupyter_arg_list(arglead, cmdline, cursorpos) abort
    let jupyter_arg_list = split(s:jupyter_arg_list_raw, ' ')
    let arglead = tolower(a:arglead)
    let ret = filter(jupyter_arg_list, '!stridx(tolower(v:val), arglead)')
    return ret
endfunction

function! s:jupyter_connect_check() abort
    if s:l_jupyter_connect != 0
        " already connected
        return
    endif

    redir => jupyter_con_out
    JupyterConnect
    sleep 2
    redir END
    for l in split(jupyter_con_out, '\n')
        if stridx(l, 'Connected') != -1
            " already connected
            let s:l_jupyter_connect = 1
            return
        endif
    endfor

    if has('win32') || has('win64')
        silent !start /min jupyter qtconsole
    else
        !jupyter qtconsole &
    endif

    let yn = input('jupyter is already open?')
    JupyterConnect
    sleep 2
    let s:l_jupyter_connect = 1

endfunction

function! s:jupyter_wrapper(...) abort
    if a:0 == 0
        let jmode = 'Start'
    else
        let jmode = a:1
    endif
    let mode_check = 0
    for mode_list in split(s:jupyter_arg_list_raw, ' ')
        if jmode == mode_list
            let mode_check = 1
        endif
    endfor
    if mode_check == 0
        echo 'incorrect argument'
        return
    endif

    call s:jupyter_connect_check()

    if jmode == 'Start'
        "do nothing
    elseif jmode == 'Connect'
        let s:l_jupyter_connect = 0
        call s:jupyter_connect_check()
    elseif jmode == 'File'
        JupyterRunFile
        return
    elseif jmode == 'Count'
        if a:0 >= 2
            let header = a:2
        else
            let header = ''
        endif
        execute header.'JupyterSendCount'
    elseif jmode == 'Range'
        if a:0 == 2
            let header = a:2
        elseif a:0 > 2
            let header = a:2.','.a:3
        else
            let header = ''
        endif
        execute header.'JupyterSendRange'
    elseif jmode == 'Cell'
        JupyterSendCell
    elseif jmode == 'Code'
        let send_code = ''
        for i in range(2,a:0)
            let send_code .= ' '.a:{i}
        endfor
        execute 'JupyterSendCode "'.send_code.'"'
    elseif jmode == 'Cd'
        if a:0 == 2
            let cdir = a:2
        else
            let cdir = ''
        endif
        execute 'JupyterCd '.cdir
    elseif jmode == 'Restart'
        JupyterSendCode 'import os; os._exit(00)'
    endif
endfunction

command! -nargs=* -complete=customlist,s:jupyter_arg_list Jupyter call s:jupyter_wrapper(<f-args>)
" }}}
'''

[[plugins]]
repo = 'prabirshrestha/vim-lsp'
on_event = 'VimEnter'
hook_source = '''
""" vim-lsp {{{
" https://qiita.com/kitagry/items/216c2cf0066ff046d200
" errorとかwarning表示はとりあえずoff
let g:lsp_diagnostics_enabled = 0
" highlightはvim-cursorwordで表示しているので使わない
let g:lsp_document_highlight_enabled = 0
" LspPeekDefinition で表示する位置
let g:lsp_peek_alignment = 'top'
" 文字入力中にhelpを出さないようにしている？
let g:lsp_signature_help_enabled = 0
""" }}}
'''
hook_post_source = '''
""" vim-lsp {{{
" reference: lsp_settings#profile#status()
function! <SID>chk_lsp_running()
    let active_servers = lsp#get_allowed_servers()
    if empty(active_servers)
        echomsg 'no Language server'
        return 0
    endif
    for active_server in active_servers
        let lsp_status = lsp#get_server_status(active_server)
        if lsp_status == 'running'
            return 1
        else
            echomsg lsp_status
        endif
    endfor
    return 0
endfunction
" lsp server が動いていればc-]でreferenceを開いて，c-jで定義をpopupで開く
let s:lsp_map1 =  maparg('<c-]>', 'n')
if empty(s:lsp_map1)
    let s:lsp_map1 = '<c-]>'
endif
let s:lsp_map2 =  maparg('<c-j>', 'n')
if empty(s:lsp_map2)
    let s:lsp_map2 = '<c-j>'
endif
let s:lsp_map3 =  maparg('<c-p>', 'n')
if empty(s:lsp_map3)
    let s:lsp_map3 = '<c-p>'
endif
let s:lsp_map4 =  maparg('<c-p><c-p>', 'n')
if empty(s:lsp_map4)
    let s:lsp_map4 = '<c-p><c-p>'
endif
execute "nnoremap <silent> <expr> <c-]> <SID>chk_lsp_running()==1 ? ':LspDefinition<CR>' : '".s:lsp_map1."'"
execute "nnoremap <silent> <expr> <c-j> <SID>chk_lsp_running()==1 ? ':LspReferences<CR>' : '".s:lsp_map2."'"
execute "nnoremap <silent> <expr> <c-p> <SID>chk_lsp_running()==1 ? ':LspHover<CR>' : '".s:lsp_map3."'"
execute "nnoremap <silent> <expr> <c-p><c-p> <SID>chk_lsp_running()==1 ? ':LspPeekDefinition<CR>' : '".s:lsp_map4."'"

" normal modeでmouseが使えないとscroll出来ないので，とりあえず対処。
" lsp_float_closed がvimだとpopupが閉じても叩かれない？ので，qで閉じるようにする
autocmd User lsp_float_opened nnoremap <buffer> <expr> <c-d> lsp#scroll(+5)
autocmd User lsp_float_opened nnoremap <buffer> <expr> <c-u> lsp#scroll(-5)
autocmd User lsp_float_opened nmap <buffer> <silent> q <Plug>(lsp-preview-close)
autocmd User lsp_float_closed nunmap <buffer> <c-d>
autocmd User lsp_float_closed nunmap <buffer> <c-u>
autocmd User lsp_float_closed nunmap <buffer> q
""" }}}
'''

[[plugins]]
repo = 'mattn/vim-lsp-settings'
on_source = 'vim-lsp'

# 新世代(2021) dark deno-powered completion framework
[[plugins]]
repo = 'Shougo/ddc.vim'
if = '''exists('g:loaded_denops') && g:loaded_denops==1'''
on_event = 'InsertEnter'
hook_post_source = '''
"""""ddc.vim {{{
" add sources
call ddc#custom#patch_global('sources', ['file', 'vim-lsp', 'around', 'neosnippet'])
" set basic options
call ddc#custom#patch_global(
    \ 'sourceOptions', {
        \ '_': {
            \ 'matchers': ['matcher_head'],
            \ 'sorters': ['sorter_rank']
        \ },
    \ })

" set sorce-specific options
call ddc#custom#patch_global(
    \ 'sourceOptions', {
        \ 'around': {
            \ 'mark': 'A',
        \ },
        \ 'file': {
            \ 'mark': 'F',
            \ 'isVolatile': v:true,
            \ 'forceCompletionPattern': '\S/\S*',
        \ },
        \ 'neosnippet': {
            \ 'mark': 'ns',
            \ 'dup': v:true,
        \ },
        \ 'tabnine': {
            \ 'mark': 'TN',
            \ 'maxCandidate': 5,
            \ 'isVolatile': v:true,
        \ },
        \ 'vim-lsp': {
            \ 'mark': 'lsp',
        \ },
    \ },
    \ 'sourceParams', {
        \ 'tabnine': {
            \ 'maxNumResults': 10,
            \ 'storageDir': expand('~/.cache/ddc-tabline'),
        \ },
    \ }
\ )
" storageDir doesn't work??

" set filetype-specific options
call ddc#custom#patch_filetype(['ps1', 'dosbatch', 'autohotkey', 'registry'], {
    \ 'sourceOptions': {
        \ 'file': {
            \ 'forceCompletionPattern': '\S\\\S*',
        \ },
    \ },
    \ 'sourceParams': {
        \ 'file': {
            \ 'mode': 'win32',
        \ },
    \ }
\ })
call ddc#custom#patch_filetype(['vim', 'toml'], {
    \ 'sources': ['necovim', 'file', 'around'],
    \ 'sourceOptions': {
        \ 'necovim': {
            \ 'mark': 'vim',
            \ 'maxCandidate': 5,
        \},
    \}
\ })
call ddc#custom#patch_filetype(['python', 'c', 'cpp'], {
    \ 'sources': ['file', 'vim-lsp', 'around', 'tabnine'],
\ })

" Mappings
" <TAB>: completion.
inoremap <silent><expr> <TAB>
\ pumvisible() ? '<C-n>' :
\ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
\ '<TAB>' : ddc#map#manual_complete()
" <S-TAB>: completion back.
inoremap <expr><S-TAB>  pumvisible() ? '<C-p>' : '<C-h>'

" automatically close preview window.
autocmd deinLocal CompleteDone * silent! pclose!

" on.
call ddc#enable()
" }}}
'''

# plugins for ddc.vim {{{
[[plugins]]
repo = 'Shougo/ddc-around'
on_source = ['ddc.vim']

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = ['ddc.vim']

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = ['ddc.vim']

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = ['ddc.vim']

[[plugins]]
repo = 'LumaKernel/ddc-tabnine'
on_source = ['ddc.vim']

[[plugins]]
repo = 'shun/ddc-vim-lsp'
on_source = ['ddc.vim']
# }}}

