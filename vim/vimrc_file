"vimrcを再読込する際にautocmdが重複しないようにautocmdをすべて解除
augroup local
    autocmd!
augroup END

"windiws, unix系で分岐
if has('win32')
    let g:vimdir = expand('~/vimfiles/')
else
    let g:vimdir = expand('~/.vim/')
endif

""##########基本設定 "{{{
"左端に数字を表示
set number
"常にステータスラインを表示
set laststatus=2
"カーソルの位置を表示
set ruler
"コマンドラインの画面上の行数
set cmdheight=2
"文の折り返し
set wrap
"タイトルを非表示
set notitle
"viとの互換性をとらない
set nocompatible
"タブの幅
set tabstop=4
"自動でインデントを挿入
set autoindent
"オートインデントの幅
set shiftwidth=4
"文字の色づけ
syntax on
"検索したときにハイライト
set hlsearch
"右下に入力コマンドを表示
set showcmd
"バックスペースのノーマルモード、(改行、)オートインデントへの有効化
set backspace=start,indent
"set backspace=start,eol,indent
"挿入モードでのマウスの有効化
set mouse=i
"全モードでのマウスの有効化
"set mouse=a
"タブをスペースに変換
set expandtab
"連続した空白でtabやback spaceが動く幅
set softtabstop=4
"日本語OKに
set encoding=utf-8
set fileencoding=utf-8
"大文字、小文字を区別しない
set ignorecase
"検索文字に大文字があると区別する
set smartcase
"タブとかを可視化?
"set listchars=tab:»-,trail:-,extends:»,precedes:«,nbsp:%,eol:↲
"clipboardとyankを共有 (+clipboardが条件)
set clipboard+=unnamed
"検索のときに移動しない
set noincsearch
"カーソルが上下５行に行ったらスクロール
set scrolloff=5
"候補の出方を良い感じに
"http://boscono.hatenablog.com/entry/2013/11/17/230740
set wildmenu
set wildmode=longest,full
set foldenable
set foldmethod=marker
"縦分割時に右に出る
set splitright
"Leaderを<space>に設定
let mapleader = "\<space>"
"doc directoryを追加
if isdirectory(g:vimdir . 'doc')
    execute "helptags " . g:vimdir . "doc"
endif

"let g:hybrid_use_Xresources = 1
"colorscheme hybrid
"全角スペース表示
hi ZenkakuSpace cterm=underline ctermfg=lightblue guibg=darkgray
match ZenkakuSpace /　/

"カーソルの下に下線を表示
set cursorline

"swp fileあり、backup, undoなし
set swapfile
execute "set directory=" . g:vimdir . "swp"
set nobackup
set noundofile

"grepコマンドで内部grep(vimgrep)を使う
"set grepprg=internal
"外部grepを数字付き,再帰的,大文字小文字区別なし,binary無視で使う
set grepprg=grep\ -n\ -r\ -i\ --binary-files=without-match
"vimgrepした際に新規windowで開くようにする
autocmd local QuickFixCmdPost *grep* cwindow

set statusline=%f%m%r%h%w   " ファイル名 修正フラグ 読込専用 ヘルプ preview_window
set statusline+=%<%=%y\ %l/%L\ [%P] " 切り詰め位置 右端に表示 filetype 今の行/全体の行 [%表示]
"autocmd local Filetype qf setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%l/%L\ %P
"See $VIMRUNTIME/ftplugin/qf.vim to change quickfix window statusline
"}}}

""##########mapping設定 "{{{

"誤って使うとまずいkeymapを削除
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>

"Insert modeを抜けるときにIME off ※ssh先ではhostのを変えるので意味なし
if has("win32")
    inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
endif

"macでinsert modeから抜けるときにIME off
"参考：https://rcmdnk.com/blog/2017/03/10/computer-mac-vim/
if has('mac')
	let g:imeoff = 'osascript -e "tell application \"System Events\" to key code 102"'
	autocmd local InsertLeave * :call system(g:imeoff)
endif
set ttimeoutlen=1

"使いやすいようにmapping
nnoremap s <c-w>
"nnoremap T :tablast <bar> :tabnew<space>
nnoremap T :tabnew<space>
nnoremap <silent> co :botright copen<CR>
nnoremap <silent> cc :cclose<CR>
nnoremap <silent> cn :cnewer<CR>
nnoremap <silent> cp :colder<CR>
nnoremap / /\v
nnoremap * /\v<><CR>
nnoremap g<Right> gt
nnoremap g<Left> gT
nnoremap gl gt
nnoremap gh gT
nnoremap <silent> 0gt :tablast<CR>
nnoremap <silent> g> :tabmove +1<CR>
nnoremap <silent> g< :tabmove -1<CR>
"大文字にするとファイル全体に適用
nnoremap zO zR
nnoremap zC zM
"そしてenterで開く下を追加したので消そうと思ったけど、macだとうまくいかなかったので残す
"nnoremap <silent> <CR><CR> za
"右方向で開く
nnoremap <expr> l foldclosed(line('.')) != -1 ? 'zo' : 'l'
nnoremap <expr> <Right> foldclosed(line('.')) != -1 ? 'zo' : 'l'

"shiftは逆動作だと思ってるので、単語移動をremap
noremap W b
noremap gw W
noremap gW B
noremap E ge
noremap ge E

"ヘッダーファイルをタブで開く
nnoremap gf <c-w>gf

"quick fix windowを新規windowで開いたとき、]でもとのwindowに戻る
"autocmd local Filetype qf nnoremap <buffer> <Esc> <c-w>p
"autocmd local Filetype qf nnoremap <buffer> <Esc> <c-w>l <c-w>k
autocmd local Filetype qf nnoremap <buffer> ] <c-w>l <c-w>k
"quick fix windowでc-tで新しいtabで開く
autocmd local Filetype qf nnoremap <buffer><silent> <c-t> <c-w><s-t><CR>:cclose<CR>
""terminal上だと矢印キーでの挙動がおかしくなるので、強制的にmapping
""入力方法はc-vから矢印
"if !has('win32')
"    nnoremap OA k
"    nnoremap OB j
"    nnoremap OD h
"    nnoremap OC l
"endif

"\で検索のハイライトを消す
nnoremap <silent> \ :nohlsearch<CR>
" }}}

""##########作成関数とか{{{
"ls in vim
command! LS 0tabnew .

"単語のハイライト情報をget "{{{
"from http://cohama.hateblo.jp/entry/2013/08/11/020849
function! s:get_syn_id(transparent)
  let synid = synID(line("."), col("."), 1)
  if a:transparent
    return synIDtrans(synid)
  else
    return synid
  endif
endfunction
function! s:get_syn_attr(synid)
  let name = synIDattr(a:synid, "name")
  let ctermfg = synIDattr(a:synid, "fg", "cterm")
  let ctermbg = synIDattr(a:synid, "bg", "cterm")
  let guifg = synIDattr(a:synid, "fg", "gui")
  let guibg = synIDattr(a:synid, "bg", "gui")
  return {
        \ "name": name,
        \ "ctermfg": ctermfg,
        \ "ctermbg": ctermbg,
        \ "guifg": guifg,
        \ "guibg": guibg}
endfunction
function! s:get_syn_info()
  let baseSyn = s:get_syn_attr(s:get_syn_id(0))
  echo "name: " . baseSyn.name .
        \ " ctermfg: " . baseSyn.ctermfg .
        \ " ctermbg: " . baseSyn.ctermbg .
        \ " guifg: " . baseSyn.guifg .
        \ " guibg: " . baseSyn.guibg
  let linkedSyn = s:get_syn_attr(s:get_syn_id(1))
  echo "link to"
  echo "name: " . linkedSyn.name .
        \ " ctermfg: " . linkedSyn.ctermfg .
        \ " ctermbg: " . linkedSyn.ctermbg .
        \ " guifg: " . linkedSyn.guifg .
        \ " guibg: " . linkedSyn.guibg
endfunction
command! SyntaxInfo call s:get_syn_info()
" }}}

"vimでbinary fileを見る "{{{
function! FT_Binary(on_off)
    if a:on_off == 1
        if exists("t:old_ft")
            echo "already open as binary editor"
            return
        endif
        "前の値を避難させる
        let t:old_ft = &filetype
        "let t:old_disp = &display
        "binay modeで開く
        if ! exists("t:pp_bin")
            e ++bin
            let t:pp_bin = 0
        endif
        "不可視文字をHexフォーマットで
        "set display=uhex
        "バイナリエディタっぽく
        %!xxd
        set filetype=xxd

        nnoremap :q :execute "%!xxd -r"<CR> :q
        nnoremap :wq :execute "%!xxd -r"<CR> :wq

    else
        if ! exists('t:old_ft')
            echo "not opened as binary editor yet"
            return
        endif
        %!xxd -r
        "e ++nobin
        "execute "set display=" . t:old_disp
        execute "set filetype=" . t:old_ft

        unmap :wq
        unmap :q
        unlet t:old_ft
        "unlet t:old_disp

    endif
endfunction

command! FTBinOn call FT_Binary(1)
command! FTBinOff call FT_Binary(0)
" }}}

"ファイルが読み込めない事があるので、その時用にread onlyをつけてencodeし直して開く関数 "{{{

function! s:noeol_reenc()
    if &endofline == 0
        set readonly
        e ++enc=utf-8
    endif
endfunction

"そしてファイルを開くたびに行うようにautocmd化
autocmd local BufRead * :call s:noeol_reenc()
" }}}

"tabの表示を快適に {{{
" https://qiita.com/wadako111/items/755e753677dd72d8036d
" Anywhere SID.
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

" Set tabline.
" total tab number
let g:AllTabNo = 10
function! s:my_tabline() 
    let endplus = 3
    if g:AllTabNo < 6
        let endplus = g:AllTabNo/2
    endif
    let st = 1
    let en = tabpagenr('$')
    let beginstr = ''
    let laststr = ''
    let is_edit = ''
    "  以降の例は all no = 10 end plus = 3
    if g:AllTabNo < en  "tabが指定数より多い場合 例では全ファイル数は13
        if tabpagenr()+endplus > g:AllTabNo " 現在 8とか
            let en = tabpagenr()+endplus
            let laststr = '...'
            if en >= tabpagenr('$')  " 現在11とか。足すと余る場合
                let en = tabpagenr('$')
                let laststr = ''
            endif
            let st = en - (g:AllTabNo-1)
        else    " 現在 6とか。
            let en = g:AllTabNo
            let laststr = '...'
        endif
    endif
    if st > 1
        let beginstr = '..'
    endif
    let s = ''
    for i in range(1,tabpagenr('$'))
        let bufnrs = tabpagebuflist(i)
        let bufnr = bufnrs[tabpagewinnr(i) - 1]
        if getbufvar(bufnr, '&modified') == 1
            let is_edit = '_*_'
        endif
    endfor
    let s .= is_edit
    let s .= beginstr
    for i in range(st, en)
        let bufnrs = tabpagebuflist(i)
        let bufnr = bufnrs[tabpagewinnr(i) - 1]  " first window, first appears
        let no = i  " display 0-origin tabpagenr.
        let mod = getbufvar(bufnr, '&modified') ? '[+]' : ''
        let title = fnamemodify(bufname(bufnr), ':t')
        if getbufvar(bufnr, '&filetype') == 'qf'
            let title = "QuickFix"
        endif
        let title = '[' . title . ']'
        let s .= '%'.i.'T'
        let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
        let s .= no . ':' . title . mod
        "let s .= mod
        let s .= '%#TabLineFill# '
    endfor
    let s .= laststr
    let s .= '%#TabLineFill#%T%=%#TabLine#'
    return s
endfunction
let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
set showtabline=2 " 常にタブラインを表示
" }}}

"開いているファイル情報を表示（ざっくり）{{{
if has('win32')
    let s:ls = 'dir '
else
    let s:ls='ls -l '
endif
command! FileInfo execute "!" . s:ls . expand('%')
"}}}

"分割した際の幅の変化一気にできるようにして、を見た目と一致するようにしたい。{{{
function! s:set_bandmap()
    "let s:cmd1 = "<c-w>"
    "let s:cmd2 = "<c-w>"
    let s:cmd1 = "s"
    let s:cmd2 = "s"
    for i in range(1, 30)
        let s:cmd1 = s:cmd1 . ">"
        let s:cmd2 = s:cmd2 . "<"
        execute "nnoremap " . s:cmd1 . " " . i . "<c-w>>"
        execute "nnoremap " . s:cmd2 . " " . i . "<c-w><"
        if winnr() != 1 && winnr() == winnr('$')
            "windowの最後のbufferだけ変更
            execute "nnoremap " . s:cmd1 . " " . i . "<c-w><"
            execute "nnoremap " . s:cmd2 . " " . i . "<c-w>>"
        endif
    endfor
endfunction
autocmd WinEnter * call s:set_bandmap()
"}}}

"clipboardを新しいwindowに保存{{{
function! Show_clipboard()
    """ open ... 1 open 0 ... get back
    execute( winnr('$') . 'wincmd l')
    if &filetype != 'clipboard'
        silent botright vertical 20split ClipBoard
        setlocal noreadonly
        setlocal number
        setlocal noswapfile
        setlocal nobackup
        setlocal noundofile
        setlocal filetype=clipboard
        setlocal buftype=nofile
        setlocal nobuflisted
        setlocal wrap
        setlocal report=9999
    endif
    put *
    wincmd p

endfunction
nnoremap <Leader>p :call Show_clipboard()<CR>
"}}}

"diff系command {{{

command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis
command! -nargs=1 -complete=file Diff vertical diffsplit <args>
"}}}

" 開いているfile一覧 {{{
function! s:file_list()
    " tab number
    for i in range(1,tabpagenr('$'))
        let l:tab_files = i
        let l:tab_files .= ' '
        "buffer number of each window
        for j in tabpagebuflist(i)
            let mod = getbufvar(j, '&modified') ? '[+]' : ''
            let l:fname =  '[ ' . fnamemodify(bufname(j),':t') . mod . ' ] '
            "let l:fname =  '[ ' . bufname(j) . mod . ' ] '
            if getbufvar(j, '&filetype') == 'qf'
                let l:fname = '[ QuickFix' . mod . ']'
            endif
            let l:tab_files .= l:fname
        endfor
        echo l:tab_files
    endfor
endfunction

command! Tls call s:file_list()

nnoremap <silent> <space>l :Tls<CR>

" }}}

" }}}

""##########file, directory変数 "{{{
autocmd local BufRead * let b:cfile = expand("%:p")
autocmd local BufRead * let b:cdir = expand("%:p:h")


"検索pathを追加
set path+=../include
if exists("$LD_LIBRARY_PATH")
    set path+=$LD_LIBRARY_PATH
endif
"}}}

""##########ファイル読み込み "{{{
"dein directoryがあれば読み込み
if isdirectory(g:vimdir . 'dein')
    execute "source " . g:vimdir . "rcdir/vimrc.dein"
endif

"pluginの設定読み込み
if isdirectory(g:vimdir . 'plugin') || isdirectory(g:vimdir . 'dein')
    execute "source " . g:vimdir . "rcdir/vimrc.plugin"
endif

"local設定ファイル
let s:localrc = g:vimdir . 'rcdir/vimrc.mine'
if filereadable(s:localrc)
    execute "source " . s:localrc
endif

"言語毎の設定
autocmd local FileType python execute "source " . g:vimdir . "rcdir/python.vim"
autocmd local FileType vim execute "source " . g:vimdir . "rcdir/vim.vim"

"カラーの変更
if filereadable(g:vimdir . "colors/inkpot.vim") && !has('gui_running')
    colorscheme inkpot
    execute "source " . g:vimdir . "rcdir/vimrc.color"
else
    colorscheme desert
endif
"}}}

