" encoding setting
" encoding setting for vim system
set encoding=utf-8
" encoding setting for current buffer
set fileencoding=utf-8
" encoding setting for all buffer
set fileencodings=utf-8
" encoding setting for vim script
scriptencoding utf-8

"vimrcを再読込する際にautocmdが重複しないようにautocmdをすべて解除
augroup local
    autocmd!
augroup END

"neovim, windiws, unix系で分岐
if has('nvim')
    if exists("$XDG_CONFIG_HOME")
        let g:vimdir = expand($XDG_CONFIG_HOME . "/nvim/")
    else
        let g:vimdir = expand('~/.config/nvim/')
    endif
else
    if has('win32')
        let g:vimdir = expand('~/vimfiles/')
    else
        let g:vimdir = expand('~/.vim/')
    endif
endif

"local設定ファイル (1st)
let s:initrc = g:vimdir . 'rcdir/init.vim.mine'
if filereadable(s:initrc)
    execute "source " . s:initrc
endif

" basic setup (set, map系) 読み込み
let s:basicrc = g:vimdir . 'rcdir/vimrc_basic.vim'
if filereadable(s:basicrc)
    execute "source " . s:basicrc
else
    echohl Error
    echo "basic setup Run Command file can't be readed!!!"
    echo "end setting"
    echohl None
    finish
endif

""##########autocmd系 "{{{
autocmd local BufEnter * let b:no_match_paren = 1   " tentative? because of paren error (Highlight_matching_Pair()).

" remove tags information when open new tab.
if exists("*settagstack")
    autocmd local TabNew * call settagstack(winnr(), {'length':0, 'curidx':1, 'items':[]})
endif

" toml fileのfiletypeをtomlにする
autocmd local BufEnter *.toml set filetype=toml

"vimgrepした際に新規windowで開くようにする
autocmd local QuickFixCmdPost *grep* cwindow

"quick fix windowでc-tで新しいtabで開く
autocmd local Filetype qf nnoremap <buffer><silent> <c-t> <c-w><s-t><CR>:cclose<CR>

"autocmd local Filetype qf setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%l/%L\ %P
"See $VIMRUNTIME/ftplugin/qf.vim to change quickfix window statusline
" }}}

""########## (簡単な)作成関数とか{{{
"ls in vim
command! LS 0tabnew .

""statusline setting {{{
let g:l_st_fileformat = {"":"", "unix":"unix,LF", "mac":"mac,CR", "dos":"dos,CRLF"}
" ファイル名 修正フラグ 読込専用 ヘルプ preview_window
" 切り詰め位置 右端に表示
" filetype
" file format
" 今の行/全体の行 [%表示]
""" the variable to administer statusline
let g:l_statusline = [
            \"%f%m%{&readonly?'[RO]':''}%h%w  ",
            \"%<%=",
            \"%y ",
            \"[%{g:l_st_fileformat[&fileformat]}:%{&fileencoding}] ",
            \"%l/%L [%P]"
            \]

let g:l_statusline_off = ["%t%m%{&readonly?'[RO]':''}%h%w"]
""" control statusline showing
let g:l_st_width_level = [30, 50]
function! Set_statusline(...)
    if a:0 == 0
        let l:st_list1 = g:l_statusline
    else
        let l:st_list1 = a:1
    endif

    if winwidth(".") < g:l_st_width_level[0]
        let l:st_list2 = [l:st_list1[0]]
    elseif winwidth(".") < g:l_st_width_level[1]
        if len(st_list1) >= 3
            let l:st_list2 = [l:st_list1[0], l:st_list1[1], l:st_list1[-1]]
        else
            let l:st_list2 = [l:st_list1[0]]
        endif
    else
        let l:st_list2 = l:st_list1
    endif

    let l:st_str = ""
    for l:st in l:st_list2
        let l:st_str .= l:st
    endfor

    return l:st_str
endfunction
set statusline=%!Set_statusline()

"}}}

"vimでbinary fileを見る "{{{
function! FT_Binary(on_off)
    if a:on_off == 1
        if exists("t:l_old_ft")
            echo "already open as binary editor"
            return
        endif
        "前の値を避難させる
        let t:l_old_ft = &filetype
        "let t:l_old_disp = &display
        "binay modeで開く
        if ! exists("t:l_pp_bin")
            e ++bin
            let t:l_pp_bin = 0
        endif
        "不可視文字をHexフォーマットで
        "set display=uhex
        "バイナリエディタっぽく
        %!xxd
        set filetype=xxd

        "nnoremap :q :execute "%!xxd -r"<CR> :q
        "nnoremap :wq :execute "%!xxd -r"<CR> :wq

    else
        if ! exists('t:l_old_ft')
            echo "not opened as binary editor yet"
            return
        endif
        %!xxd -r
        "e ++nobin
        "execute "set display=" . t:l_old_disp
        execute "set filetype=" . t:l_old_ft

        "unmap :wq
        "unmap :q
        unlet t:l_old_ft
        "unlet t:l_old_disp

    endif
endfunction

command! FTBinOn call FT_Binary(1)
command! FTBinOff call FT_Binary(0)
" }}}

"ファイルが読み込めない事があるので、その時用にread onlyをつけてencodeし直して開く関数 "{{{

function! s:noeol_reenc()
    if &endofline == 0
        if input("reencode? 'y' or 'n'")=='y'
            set readonly
            e ++enc=utf-8
        endif
    endif
endfunction

"そしてファイルを開くたびに行うようにautocmd化
autocmd local BufRead * :call s:noeol_reenc()
" }}}

"tabの表示を快適に {{{
" https://qiita.com/wadako111/items/755e753677dd72d8036d
" Anywhere SID.
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

" Set tabline.
function! s:my_tabline() 
    let beginstr = ''
    let laststr = ''
    let is_edit = ''

    let titles = []
    for i in range(1, tabpagenr('$'))
        let no = i  " display 0-origin tabpagenr.
        let bufnrs = tabpagebuflist(i)
        let bufnr = bufnrs[tabpagewinnr(i) - 1]  " first window, first appears
        let mod = getbufvar(bufnr, '&modified') ? '[+]' : ''
        let title = fnamemodify(bufname(bufnr), ':t')
        if getbufvar(bufnr, '&filetype') == 'qf'
            let title = "QuickFix"
        endif
        let title = '[' . title . ']'
        let title = no . ':' . title
        call add(titles, title)

        if getbufvar(bufnr, '&modified') == 1
            let is_edit = '_*_'
        endif
    endfor

    let width = &columns
    let cur_tab_no = tabpagenr()
    let st = cur_tab_no
    let en = cur_tab_no
    let tab_len = len(titles[cur_tab_no-1]) + 5   " 5 ... (max) len(beginstr+laststr) + 1
    let tab_len += len(is_edit)
    for i in range(1, tabpagenr('$'))
        let ctn_p = en+1
        if ctn_p <= tabpagenr('$')
            let tab_len += len(titles[ctn_p-1])+1
            if tab_len <= width
                let en = ctn_p
            else
                break
            endif
        endif

        let ctn_m = st-1
        if ctn_m >= 1
            let tab_len += len(titles[ctn_m-1])+1
            if tab_len <= width
                let st = ctn_m
            else
                break
            endif
        endif
    endfor

    if st > 1
        let beginstr = '..'
    endif
    if en < tabpagenr('$')
        let laststr = '..'
    endif

    let s = ''
    let s .= is_edit
    let s .= beginstr
    for i in range(st, en)
        let s .= '%'.i.'T'
        let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
        let s .= titles[i-1]
        "let s .= mod
        let s .= '%#TabLineFill# '
    endfor
    let s .= laststr
    let s .= '%#TabLineFill#%T%=%#TabLine#'
    return s
endfunction

let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
set showtabline=2 " 常にタブラインを表示
" }}}

"開いているファイル情報を表示（ざっくり）{{{
if has('win32')
    let s:ls = 'dir '
else
    let s:ls='ls -l '
endif
command! FileInfo execute "!" . s:ls . expand('%')
"}}}

" 新しいtabで関数ジャンプする {{{
function! <SID>Tab_Jump()
    let l:ctabnr = tabpagenr()
    let l:cword = expand('<cword>')
    silent cd %:h
    tabnew
    " tag listを初期化
    try
        $pop
    catch
    endtry
    execute "tjump " . l:cword
    if expand("%:t") == ""
        quit
        execute "normal! " . l:ctabnr . "gt"
    endif
    silent cd -
endfunction

"jump先をnew tabで開く
nnoremap <silent> <c-j> :call <SID>Tab_Jump()<CR>

" }}}

"clipboardを新しいwindowに保存{{{
function! Show_clipboard()
    """ open ... 1 open 0 ... get back
    execute( winnr('$') . 'wincmd l')
    if &filetype != 'clipboard'
        silent botright vertical 20split ClipBoard
        setlocal noreadonly
        setlocal number
        setlocal noswapfile
        setlocal nobackup
        setlocal noundofile
        setlocal filetype=clipboard
        setlocal buftype=nofile
        setlocal nobuflisted
        setlocal wrap
        setlocal report=9999
    endif
    put *
    wincmd p

endfunction
nnoremap <Leader>p :call Show_clipboard()<CR>
"}}}

" 関数じゃないけどInsertを抜けるときに日本語入力をoff {{{
"Insert modeを抜けるときにIME off ※ssh先ではhostのを変えるので意味なし
if has("win32") && exists('g:l_auto_ime_off')
    inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
endif

"macでinsert modeから抜けるときにIME off
"参考：https://rcmdnk.com/blog/2017/03/10/computer-mac-vim/
if has('mac') && exists('g:l_auto_ime_off')
    let g:l_imeoff = 'osascript -e "tell application \"System Events\" to key code 102"'
    autocmd local InsertLeave * :call system(g:l_imeoff)
endif
set ttimeoutlen=1

" }}}

"diff系command {{{

command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis
command! -nargs=1 -complete=file Diff vertical diffsplit <args>
"}}}

"" active window {{{

"let g:l_cur_winnr = 1
"autocmd local WinEnter let g:l_cur_winnr = winnr()
autocmd local WinEnter ?* set statusline=%!Set_statusline()
autocmd local WinLeave ?* setlocal statusline=%!Set_statusline(g:l_statusline_off)
""" ?* ... to igonore setting quick-fix window

""}}}

" conflict commentを検索
command! SearchConf /<<<<<<<\|=======\|>>>>>>>

" expandを打つのがめんどくさい
command! -nargs=1 Echopand echo expand(<f-args>)

" self-made plugin/functionファイル読み込み
let s:plugin_file = g:vimdir . "rcdir/vimrc_plugin.vim"
if filereadable(s:plugin_file)
    execute "source " . s:plugin_file
endif

" nnoremap <Leader><Leader> :map mapleader<CR>
function! <SID>leader_map()
    map <Leader>
endfunction
nnoremap <silent> <Leader><Leader> :call <SID>leader_map()<CR>
" }}}

""##########file, directory関連 "{{{
autocmd local BufRead * let b:cfile = expand("%:p")
autocmd local BufRead * let b:cdir = expand("%:p:h")

let g:l_last_file = {'win':'', 'tab':''}
autocmd local WinLeave * let g:l_last_file['win'] = expand("%:p")
autocmd local TabClosed * let g:l_last_file['tab'] = g:l_last_file['win']
command! LastTab execute "tabnew " . g:l_last_file['tab']
command! LastWin execute "vsplit " . g:l_last_file['win']

"検索pathを追加
set path+=../include
if exists("$LD_LIBRARY_PATH")
    set path+=$LD_LIBRARY_PATH
endif

" test用directoryを追加
let s:test_vim_dir = g:vimdir . 'test'
if !isdirectory(s:test_vim_dir)
    call mkdir(s:test_vim_dir)
endif
execute 'set runtimepath^=' . s:test_vim_dir
"}}}

""##########ファイル読み込み "{{{
"dein directoryがあれば読み込み
let s:dein_file = g:vimdir . "rcdir/vimrc_dein.vim"
if isdirectory(g:vimdir . 'dein') && filereadable(s:dein_file)
    execute "source " . s:dein_file
endif

"カラーの変更
let s:color_file = g:vimdir . "rcdir/vimrc_color.vim"
if !has('gui_running')
    if filereadable(s:color_file)
        execute "source " . s:color_file
    endif
endif

"local設定ファイル (2nd)
let s:localrc = g:vimdir . 'rcdir/vimrc.mine'
if filereadable(s:localrc)
    execute "source " . s:localrc
endif
"}}}

