"vim script encording setting
set encoding=utf-8
set fileencoding=utf-8
scriptencoding utf-8
"vimrcã‚’å†èª­è¾¼ã™ã‚‹éš›ã«autocmdãŒé‡è¤‡ã—ãªã„ã‚ˆã†ã«autocmdã‚’ã™ã¹ã¦è§£é™¤
augroup local
    autocmd!
augroup END

"windiws, unixç³»ã§åˆ†å²
if has('win32')
    let g:vimdir = expand('~/vimfiles/')
else
    let g:vimdir = expand('~/.vim/')
endif

""##########åŸºæœ¬è¨­å®š "{{{
"å·¦ç«¯ã«æ•°å­—ã‚’è¡¨ç¤º
set number
"å¸¸ã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤º
set laststatus=2
"ã‚«ãƒ¼ã‚½ãƒ«ã®ä½ç½®ã‚’è¡¨ç¤º
set ruler
"ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã®ç”»é¢ä¸Šã®è¡Œæ•°
set cmdheight=2
"æ–‡ã®æŠ˜ã‚Šè¿”ã—
set wrap
"ã‚¿ã‚¤ãƒˆãƒ«ã‚’éè¡¨ç¤º
set notitle
"viã¨ã®äº’æ›æ€§ã‚’ã¨ã‚‰ãªã„
set nocompatible
"ã‚¿ãƒ–ã®å¹…
set tabstop=4
"è‡ªå‹•ã§ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æŒ¿å…¥
set autoindent
"ã‚ªãƒ¼ãƒˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã®å¹…
set shiftwidth=4
"æ–‡å­—ã®è‰²ã¥ã‘
syntax on
"æ¤œç´¢ã—ãŸã¨ãã«ãƒã‚¤ãƒ©ã‚¤ãƒˆ
set hlsearch
"å³ä¸‹ã«å…¥åŠ›ã‚³ãƒãƒ³ãƒ‰ã‚’è¡¨ç¤º
set showcmd
"ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰ã€(æ”¹è¡Œã€)ã‚ªãƒ¼ãƒˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã¸ã®æœ‰åŠ¹åŒ–
set backspace=start,indent
"set backspace=start,eol,indent
"æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã§ã®ãƒã‚¦ã‚¹ã®æœ‰åŠ¹åŒ–
set mouse=i
"å…¨ãƒ¢ãƒ¼ãƒ‰ã§ã®ãƒã‚¦ã‚¹ã®æœ‰åŠ¹åŒ–
"set mouse=a
"ã‚¿ãƒ–ã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«å¤‰æ›
set expandtab
"é€£ç¶šã—ãŸç©ºç™½ã§tabã‚„back spaceãŒå‹•ãå¹…
set softtabstop=4
"æ—¥æœ¬èªOKã«
"set encoding=utf-8
"set fileencoding=utf-8
"å¤§æ–‡å­—ã€å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„
set ignorecase
"æ¤œç´¢æ–‡å­—ã«å¤§æ–‡å­—ãŒã‚ã‚‹ã¨åŒºåˆ¥ã™ã‚‹
set smartcase
"ã‚¿ãƒ–ã¨ã‹ã‚’å¯è¦–åŒ–?
"set list
set listchars=tab:Â».,trail:~,extends:Â»,precedes:Â«,nbsp:% ",eol:â†²
"clipboardã¨yankã‚’å…±æœ‰ (+clipboardãŒæ¡ä»¶)
set clipboard+=unnamed
"æ¤œç´¢ã®ã¨ãã«ç§»å‹•ã—ãªã„
set noincsearch
"ã‚«ãƒ¼ã‚½ãƒ«ãŒä¸Šä¸‹ï¼•è¡Œã«è¡Œã£ãŸã‚‰ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
set scrolloff=5
"å€™è£œã®å‡ºæ–¹ã‚’è‰¯ã„æ„Ÿã˜ã«
"http://boscono.hatenablog.com/entry/2013/11/17/230740
set wildmenu
set wildmode=longest,full
set foldenable
set foldmethod=marker
"ç¸¦åˆ†å‰²æ™‚ã«å³ã«å‡ºã‚‹
set splitright
"Leaderã‚’<space>ã«è¨­å®š
let mapleader = "\<space>"
"doc directoryã‚’è¿½åŠ 
if isdirectory(g:vimdir . 'doc')
    execute "helptags " . g:vimdir . "doc"
endif

"let g:hybrid_use_Xresources = 1
"colorscheme hybrid

"ã‚«ãƒ¼ã‚½ãƒ«ã®ä¸‹ã«ä¸‹ç·šã‚’è¡¨ç¤º
set cursorline

"swp fileã‚ã‚Šã€backup, undoãªã—
set swapfile
execute "set directory=" . g:vimdir . "swp"
set nobackup
set noundofile

"tagè¨­å®š
set tags=tags;,./tags;

"grepã‚³ãƒãƒ³ãƒ‰ã§å†…éƒ¨grep(vimgrep)ã‚’ä½¿ã†
"set grepprg=internal
"å¤–éƒ¨grepã‚’æ•°å­—ä»˜ã,å†å¸°çš„,å¤§æ–‡å­—å°æ–‡å­—åŒºåˆ¥ãªã—,binaryç„¡è¦–ã§ä½¿ã†
set grepprg=grep\ -nriI
"vimgrepã—ãŸéš›ã«æ–°è¦windowã§é–‹ãã‚ˆã†ã«ã™ã‚‹
autocmd local QuickFixCmdPost *grep* cwindow

"statusline setting
let g:l_st_fileformat = {"":"", "unix":"unix,LF", "mac":"mac,CR", "dos":"dos,CRLF"}
" ãƒ•ã‚¡ã‚¤ãƒ«å ä¿®æ­£ãƒ•ãƒ©ã‚° èª­è¾¼å°‚ç”¨ ãƒ˜ãƒ«ãƒ— preview_window
" åˆ‡ã‚Šè©°ã‚ä½ç½® å³ç«¯ã«è¡¨ç¤º
" filetype
" file format
" ä»Šã®è¡Œ/å…¨ä½“ã®è¡Œ [%è¡¨ç¤º]
""" the variable to administer statusline
let g:l_statusline = [
            \"%f%m%{&readonly?'[RO]':''}%h%w  ",
            \"%<%=",
            \"%y ",
            \"[%{g:l_st_fileformat[&fileformat]}:%{&fileencoding}] ",
            \"%l/%L [%P]"
            \]
" --- old Set_statusline() --- {{{
"""" 1st ... statusline list, 2nd ... local(1) or global(0)
"function! Set_statusline(...)
"    if &filetype == "qf"
"        " ignore QuickFix Window
"        return
"    endif
"    if a:0 == 0
"        let l:st_list = g:l_statusline
"    else
"        let l:st_list = a:1
"    endif
"    if (a:0 >= 2) && (a:2 == 1)
"        " local setting
"        let l:set_str = "setlocal statusline="
"        for s:st in l:st_list
"            let l:set_str .= s:st
"        endfor
"        execute l:set_str
"    else
"        "global setting
"        set statusline=
"        let l:set_str = "set"
"        for s:st in l:st_list
"            execute l:set_str . " statusline+=" . s:st
"        endfor
"    endif
"endfunction
"call Set_statusline()
" }}}

""" control statusline showing
let g:l_st_width_level = [30, 50]
function! Set_statusline(...)
    if &filetype == "qf"
        " ignore QuickFix Window
        return
    endif
    if a:0 == 0
        let l:st_list1 = g:l_statusline
    else
        let l:st_list1 = a:1
    endif

    if winwidth(".") < g:l_st_width_level[0]
        let l:st_list2 = [l:st_list1[0]]
    elseif winwidth(".") < g:l_st_width_level[1]
        if len(st_list1) >= 3
            let l:st_list2 = [l:st_list1[0], l:st_list1[1], l:st_list1[-1]]
        endif
    else
        let l:st_list2 = l:st_list1
    endif

    let l:st_str = ""
    for l:st in l:st_list2
        let l:st_str .= l:st
    endfor

    return l:st_str
endfunction
set statusline=%!Set_statusline()

"autocmd local Filetype qf setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%l/%L\ %P
"See $VIMRUNTIME/ftplugin/qf.vim to change quickfix window statusline
"}}}

""##########mappingè¨­å®š "{{{

"èª¤ã£ã¦ä½¿ã†ã¨ã¾ãšã„keymapã‚’å‰Šé™¤
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>

"Insert modeã‚’æŠœã‘ã‚‹ã¨ãã«IME off â€»sshå…ˆã§ã¯hostã®ã‚’å¤‰ãˆã‚‹ã®ã§æ„å‘³ãªã—
if has("win32")
    inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
endif

"macã§insert modeã‹ã‚‰æŠœã‘ã‚‹ã¨ãã«IME off
"å‚è€ƒï¼šhttps://rcmdnk.com/blog/2017/03/10/computer-mac-vim/
if has('mac')
	let g:l_imeoff = 'osascript -e "tell application \"System Events\" to key code 102"'
	autocmd local InsertLeave * :call system(g:l_imeoff)
endif
set ttimeoutlen=1

"ä½¿ã„ã‚„ã™ã„ã‚ˆã†ã«mapping
nnoremap s <c-w>
nnoremap sj <c-w>j
nnoremap s<Down> <c-w>j
nnoremap sk <c-w>k
nnoremap s<Up> <c-w>k
nnoremap sh <c-w>h
nnoremap s<Left> <c-w>h
nnoremap sl <c-w>l
nnoremap s<Right> <c-w>l
"nnoremap T :tablast <bar> :tabnew<space>
nnoremap T :tabnew<space>
nnoremap <silent> co :botright copen<CR>
nnoremap <silent> cc :cclose<CR>
nnoremap <silent> cn :cnewer<CR>
nnoremap <silent> cp :colder<CR>
nnoremap / /\v
nnoremap * /\v<<c-r><c-w>><CR>
nnoremap g<Right> gt
nnoremap g<Left> gT
nnoremap gl gt
nnoremap gh gT
nnoremap <silent> 0gt :tablast<CR>
nnoremap <silent> g> :tabmove +1<CR>
nnoremap <silent> g< :tabmove -1<CR>
"å¤§æ–‡å­—ã«ã™ã‚‹ã¨ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã«é©ç”¨
nnoremap zO zR
nnoremap zC zM
"Yã§è¡Œæœ«ã¾ã§ãƒ¤ãƒ³ã‚¯
nnoremap Y y$
"ãã—ã¦enterã§é–‹ãä¸‹ã‚’è¿½åŠ ã—ãŸã®ã§æ¶ˆãã†ã¨æ€ã£ãŸã‘ã©ã€macã ã¨ã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§æ®‹ã™
"nnoremap <silent> <CR><CR> za
"å³æ–¹å‘ã§å†å¸°çš„ã«é–‹ã
nnoremap <expr> l foldclosed(line('.')) != -1 ? 'zO' : 'l'
nnoremap <expr> <Right> foldclosed(line('.')) != -1 ? 'zO' : 'l'
"Enterã§ï¼‘æ®µé–‹ã„ãŸã‚Šé–‰ã˜ãŸã‚Šã™ã‚‹
nnoremap <expr> <CR> foldlevel('.') != 0 ? 'za' : '<CR>'

"shiftã¯é€†å‹•ä½œã ã¨æ€ã£ã¦ã‚‹ã®ã§ã€å˜èªç§»å‹•ã‚’remap
noremap W b
noremap gw W
noremap gW B
noremap E ge
noremap ge E

"ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¿ãƒ–ã§é–‹ã
nnoremap gf <c-w>gf

"quick fix windowã‚’æ–°è¦windowã§é–‹ã„ãŸã¨ãã€]ã§ã‚‚ã¨ã®windowã«æˆ»ã‚‹
"autocmd local Filetype qf nnoremap <buffer> <Esc> <c-w>p
"autocmd local Filetype qf nnoremap <buffer> <Esc> <c-w>l <c-w>k
autocmd local Filetype qf nnoremap <buffer> ] <c-w>k <c-w>l
"quick fix windowã§c-tã§æ–°ã—ã„tabã§é–‹ã
autocmd local Filetype qf nnoremap <buffer><silent> <c-t> <c-w><s-t><CR>:cclose<CR>
""terminalä¸Šã ã¨çŸ¢å°ã‚­ãƒ¼ã§ã®æŒ™å‹•ãŒãŠã‹ã—ããªã‚‹ã®ã§ã€å¼·åˆ¶çš„ã«mapping
""å…¥åŠ›æ–¹æ³•ã¯c-vã‹ã‚‰çŸ¢å°
"if !has('win32')
"    nnoremap OA k
"    nnoremap OB j
"    nnoremap OD h
"    nnoremap OC l
"endif

"å€™è£œãŒè¤‡æ•°ã‚ã‚‹å ´åˆã«ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
nnoremap <c-]> g<c-]>
"
nnoremap <silent> g<c-]> :vertical stjump<CR>
"jumpå…ˆã‚’new tabã§é–‹ã
nnoremap <c-j> :execute("tabnew " . b:cfile)<CR> <c-o> :execute("tjump " . expand('<cword>'))<CR>
"preview ã§é–‹ã
nnoremap <silent> <c-l> :execute("ptjump " . expand("<cword>"))<CR>

"\ã§æ¤œç´¢ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’æ¶ˆã™
nnoremap <silent> \ :nohlsearch<CR>
" }}}

""##########autocmdç³» "{{{
autocmd local BufEnter * let b:no_match_paren = 1   " tentative? because of paren error (Highlight_matching_Pair()).

" remove tags information when open new tab.
if exists("*settagstack")
    autocmd local TabNew * call settagstack(winnr(), {'length':0, 'curidx':1, 'items':[]})
endif
" }}}

""########## (ç°¡å˜ãª)ä½œæˆé–¢æ•°ã¨ã‹{{{
"ls in vim
command! LS 0tabnew .

"vimã§binary fileã‚’è¦‹ã‚‹ "{{{
function! FT_Binary(on_off)
    if a:on_off == 1
        if exists("t:l_old_ft")
            echo "already open as binary editor"
            return
        endif
        "å‰ã®å€¤ã‚’é¿é›£ã•ã›ã‚‹
        let t:l_old_ft = &filetype
        "let t:l_old_disp = &display
        "binay modeã§é–‹ã
        if ! exists("t:l_pp_bin")
            e ++bin
            let t:l_pp_bin = 0
        endif
        "ä¸å¯è¦–æ–‡å­—ã‚’Hexãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§
        "set display=uhex
        "ãƒã‚¤ãƒŠãƒªã‚¨ãƒ‡ã‚£ã‚¿ã£ã½ã
        %!xxd
        set filetype=xxd

        "nnoremap :q :execute "%!xxd -r"<CR> :q
        "nnoremap :wq :execute "%!xxd -r"<CR> :wq

    else
        if ! exists('t:l_old_ft')
            echo "not opened as binary editor yet"
            return
        endif
        %!xxd -r
        "e ++nobin
        "execute "set display=" . t:l_old_disp
        execute "set filetype=" . t:l_old_ft

        "unmap :wq
        "unmap :q
        unlet t:l_old_ft
        "unlet t:l_old_disp

    endif
endfunction

command! FTBinOn call FT_Binary(1)
command! FTBinOff call FT_Binary(0)
" }}}

"ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã‚ãªã„äº‹ãŒã‚ã‚‹ã®ã§ã€ãã®æ™‚ç”¨ã«read onlyã‚’ã¤ã‘ã¦encodeã—ç›´ã—ã¦é–‹ãé–¢æ•° "{{{

function! s:noeol_reenc()
    if &endofline == 0
        if input("reencode? 'y' or 'n'")=='y'
            set readonly
            e ++enc=utf-8
        endif
    endif
endfunction

"ãã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ããŸã³ã«è¡Œã†ã‚ˆã†ã«autocmdåŒ–
autocmd local BufRead * :call s:noeol_reenc()
" }}}

"tabã®è¡¨ç¤ºã‚’å¿«é©ã« {{{
" https://qiita.com/wadako111/items/755e753677dd72d8036d
" Anywhere SID.
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

" Set tabline.
" total tab number
let g:l_AllTabNo = 10
function! s:my_tabline() 
    "let endplus = 3
    "if g:l_AllTabNo < 6
        let endplus = g:l_AllTabNo/2
    "endif
    let st = 1
    let en = tabpagenr('$')
    let beginstr = ''
    let laststr = ''
    let is_edit = ''
    "  ä»¥é™ã®ä¾‹ã¯ all no = 10 end plus = 3
    if g:l_AllTabNo < en  "tabãŒæŒ‡å®šæ•°ã‚ˆã‚Šå¤šã„å ´åˆ ä¾‹ã§ã¯å…¨ãƒ•ã‚¡ã‚¤ãƒ«æ•°ã¯13
        if tabpagenr()+endplus > g:l_AllTabNo " ç¾åœ¨ 8ã¨ã‹
            let en = tabpagenr()+endplus
            let laststr = '...'
            if en >= tabpagenr('$')  " ç¾åœ¨11ã¨ã‹ã€‚è¶³ã™ã¨ä½™ã‚‹å ´åˆ
                let en = tabpagenr('$')
                let laststr = ''
            endif
            let st = en - (g:l_AllTabNo-1)
        else    " ç¾åœ¨ 6ã¨ã‹ã€‚
            let en = g:l_AllTabNo
            let laststr = '...'
        endif
    endif
    if st > 1
        let beginstr = '..'
    endif
    let s = ''
    for i in range(1,tabpagenr('$'))
        let bufnrs = tabpagebuflist(i)
        let bufnr = bufnrs[tabpagewinnr(i) - 1]
        if getbufvar(bufnr, '&modified') == 1
            let is_edit = '_*_'
        endif
    endfor
    let s .= is_edit
    let s .= beginstr
    for i in range(st, en)
        let bufnrs = tabpagebuflist(i)
        let bufnr = bufnrs[tabpagewinnr(i) - 1]  " first window, first appears
        let no = i  " display 0-origin tabpagenr.
        let mod = getbufvar(bufnr, '&modified') ? '[+]' : ''
        let title = fnamemodify(bufname(bufnr), ':t')
        if getbufvar(bufnr, '&filetype') == 'qf'
            let title = "QuickFix"
        endif
        let title = '[' . title . ']'
        let s .= '%'.i.'T'
        let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
        let s .= no . ':' . title . mod
        "let s .= mod
        let s .= '%#TabLineFill# '
    endfor
    let s .= laststr
    let s .= '%#TabLineFill#%T%=%#TabLine#'
    return s
endfunction
let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
set showtabline=2 " å¸¸ã«ã‚¿ãƒ–ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤º
" }}}

"é–‹ã„ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’è¡¨ç¤ºï¼ˆã–ã£ãã‚Šï¼‰{{{
if has('win32')
    let s:ls = 'dir '
else
    let s:ls='ls -l '
endif
command! FileInfo execute "!" . s:ls . expand('%')
"}}}

"clipboardã‚’æ–°ã—ã„windowã«ä¿å­˜{{{
function! Show_clipboard()
    """ open ... 1 open 0 ... get back
    execute( winnr('$') . 'wincmd l')
    if &filetype != 'clipboard'
        silent botright vertical 20split ClipBoard
        setlocal noreadonly
        setlocal number
        setlocal noswapfile
        setlocal nobackup
        setlocal noundofile
        setlocal filetype=clipboard
        setlocal buftype=nofile
        setlocal nobuflisted
        setlocal wrap
        setlocal report=9999
    endif
    put *
    wincmd p

endfunction
nnoremap <Leader>p :call Show_clipboard()<CR>
"}}}

"diffç³»command {{{

command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis
command! -nargs=1 -complete=file Diff vertical diffsplit <args>
"}}}

"" active window {{{

"let g:l_cur_winnr = 1
"autocmd local WinEnter let g:l_cur_winnr = winnr()
let g:l_statusline_off = ["%t%m%{&readonly?'[RO]':''}%h%w"]
autocmd local WinEnter * set statusline=%!Set_statusline()
autocmd local WinLeave * setlocal statusline=%!Set_statusline(g:l_statusline_off)

""}}}

""" #ã§è¡Œæœ«ã‹ã‚‰æ‹¬å¼§ã‚’è¦‹ã¤ã‘ãŸã‚Šã€æ¬¡ã®caseæ–‡ã‚’è¦‹ã¤ã‘ãŸã‚Šã—ã¦ã¨ã¶ {{{
function! <SID>chk_kakko()
    """ next case
    if &expandtab == 1
        let l:tab_str = ""
        for i in range(&tabstop)
            let l:tab_str .= " "
        endfor
    else
        let l:tab_str = "    "
    endif
    if len(split(getline("."), l:tab_str)) > 0 && len(split(getline("."), l:tab_str)[0]) > 4
        if split(getline("."), l:tab_str)[0][:3] == "case"
            for l:ln in range(line(".")+1, line("$"))
                try
                    if split(getline(l:ln), tab_str)[0][:3] == "case"
                        return l:ln . "gg"
                    elseif split(getline(l:ln), tab_str)[0][:6] == "default"
                        return l:ln . "gg"
                    endif
                catch
                    "echo v:exception
                endtry
            endfor
        endif
    endif

    """ find () or {}
    let l:src_strs = ["{", "}", "(", ")"]
    for l:ss in l:src_strs
        let l:idx = strridx(getline("."), l:ss)
        if l:idx == -1
            continue
        endif
        if l:idx == len(getline("."))-1
            return "$%"
        else
            return "$F" . l:ss . "%"
        endif
    endfor
    return ""
endfunction
nnoremap <expr> # <SID>chk_kakko()
" }}}

" self-made functionãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
if filereadable(g:vimdir . "rcdir/vimrc.func")
    execute "source " . g:vimdir . "rcdir/vimrc.func"
endif

" }}}

""##########file, directoryå¤‰æ•° "{{{
autocmd local BufRead * let b:cfile = expand("%:p")
autocmd local BufRead * let b:cdir = expand("%:p:h")

let g:l_last_file = {'win':'', 'tab':''}
autocmd local WinLeave * let g:l_last_file['win'] = expand("%:p")
autocmd local TabClosed * let g:l_last_file['tab'] = g:l_last_file['win']
command! LastTab execute "tabnew " . g:l_last_file['tab']
command! LastWin execute "vsplit " . g:l_last_file['win']

"æ¤œç´¢pathã‚’è¿½åŠ 
set path+=../include
if exists("$LD_LIBRARY_PATH")
    set path+=$LD_LIBRARY_PATH
endif
"}}}

""##########ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ "{{{
"dein directoryãŒã‚ã‚Œã°èª­ã¿è¾¼ã¿
if isdirectory(g:vimdir . 'dein')
    execute "source " . g:vimdir . "rcdir/vimrc.dein"
endif

"pluginã®è¨­å®šèª­ã¿è¾¼ã¿
if isdirectory(g:vimdir . 'plugin') || isdirectory(g:vimdir . 'dein')
    execute "source " . g:vimdir . "rcdir/vimrc.plugin"
endif

"ã‚«ãƒ©ãƒ¼ã®å¤‰æ›´
if filereadable(g:vimdir . "colors/inkpot.vim") && !has('gui_running')
    colorscheme inkpot
    execute "source " . g:vimdir . "rcdir/vimrc.color"
else
    colorscheme desert
endif

"localè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
let s:localrc = g:vimdir . 'rcdir/vimrc.mine'
if filereadable(s:localrc)
    execute "source " . s:localrc
endif
"}}}

