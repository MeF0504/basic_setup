"vim script encording setting
set encoding=utf-8
set fileencoding=utf-8
scriptencoding utf-8
"vimrcを再読込する際にautocmdが重複しないようにautocmdをすべて解除
augroup local
    autocmd!
augroup END

"neovim, windiws, unix系で分岐
if has('nvim')
    let g:vimdir = expand('~/.config/nvim/')
else
    if has('win32')
        let g:vimdir = expand('~/vimfiles/')
    else
        let g:vimdir = expand('~/.vim/')
    endif
endif

"local設定ファイル (1st)
let s:initrc = g:vimdir . 'rcdir/init.vim.mine'
if filereadable(s:initrc)
    execute "source " . s:initrc
endif

""########## shortcut comment {{{
" <c-h> ... backspace <c-m> ... Enter
" <c-i> ... tab <c-j> ... Enter?
"" }}}

""##########基本設定 "{{{
"左端に数字を表示
set number
"常にステータスラインを表示
set laststatus=2
"カーソルの位置を表示
set ruler
"コマンドラインの画面上の行数
set cmdheight=2
"文の折り返し
set wrap
"タイトルを非表示
set notitle
"viとの互換性をとらない
set nocompatible
"タブの幅
set tabstop=4
"自動でインデントを挿入
set autoindent
"オートインデントの幅
set shiftwidth=4
"文字の色づけ
syntax on
"検索したときにハイライト
set hlsearch
"右下に入力コマンドを表示
set showcmd
"バックスペースのノーマルモード、(改行、)オートインデントへの有効化
set backspace=start,indent
"set backspace=start,eol,indent
"挿入モードでのマウスの有効化
set mouse=i
"全モードでのマウスの有効化
"set mouse=a
"タブをスペースに変換
set expandtab
"連続した空白でtabやback spaceが動く幅
set softtabstop=4
"日本語OKに
"set encoding=utf-8
"set fileencoding=utf-8
"大文字、小文字を区別しない
set ignorecase
"検索文字に大文字があると区別する
set smartcase
"タブとかを可視化?
"set list
set listchars=tab:».,trail:~,extends:»,precedes:«,nbsp:% ",eol:↲
"clipboardとyankを共有 (+clipboardが条件)
set clipboard+=unnamed
"検索のときに移動しない
set noincsearch
"カーソルが上下2行に行ったらスクロール
set scrolloff=2
"候補の出方を良い感じに
"http://boscono.hatenablog.com/entry/2013/11/17/230740
set wildmenu
set wildmode=longest,full
set foldenable
set foldmethod=marker
"縦分割時に右に出る
set splitright
"Leaderを<space>に設定
let mapleader = "\<space>"
"doc directoryを追加
if isdirectory(g:vimdir . 'doc')
    execute "helptags " . g:vimdir . "doc"
endif

"let g:hybrid_use_Xresources = 1
"colorscheme hybrid

"カーソルの下に下線を表示
set cursorline

"swp fileあり、backup, undoなし
set swapfile
execute "set directory=" . g:vimdir . "swp"
set nobackup
set noundofile

"tag設定
set tags=tags;,./tags;

"terminal mode設定
"terminal-job modeでのwindow移動short cutを変更
"set termwinkey=<c-l>

" neovim specified config
if has('nvim')
    " pop-up menuを半透明にする [0-100(%)]
    set pumblend = 20
    " 置換をinteractiveに行う
    set inccommand = split
endif

"grepコマンドで内部grep(vimgrep)を使う
"set grepprg=internal
"外部grepを数字付き,再帰的,大文字小文字区別なし,binary無視で使う
set grepprg=grep\ -nriI
"vimgrepした際に新規windowで開くようにする
autocmd local QuickFixCmdPost *grep* cwindow

" 分割したwindow間で移動を同期
" (それぞれのwindowでsetする必要あり)
" set scrollbind

""statusline setting {{{
let g:l_st_fileformat = {"":"", "unix":"unix,LF", "mac":"mac,CR", "dos":"dos,CRLF"}
" ファイル名 修正フラグ 読込専用 ヘルプ preview_window
" 切り詰め位置 右端に表示
" filetype
" file format
" 今の行/全体の行 [%表示]
""" the variable to administer statusline
let g:l_statusline = [
            \"%f%m%{&readonly?'[RO]':''}%h%w  ",
            \"%<%=",
            \"%y ",
            \"[%{g:l_st_fileformat[&fileformat]}:%{&fileencoding}] ",
            \"%l/%L [%P]"
            \]

let g:l_statusline_off = ["%t%m%{&readonly?'[RO]':''}%h%w"]
""" control statusline showing
let g:l_st_width_level = [30, 50]
function! Set_statusline(...)
    if a:0 == 0
        let l:st_list1 = g:l_statusline
    else
        let l:st_list1 = a:1
    endif

    if winwidth(".") < g:l_st_width_level[0]
        let l:st_list2 = [l:st_list1[0]]
    elseif winwidth(".") < g:l_st_width_level[1]
        if len(st_list1) >= 3
            let l:st_list2 = [l:st_list1[0], l:st_list1[1], l:st_list1[-1]]
        else
            let l:st_list2 = [l:st_list1[0]]
        endif
    else
        let l:st_list2 = l:st_list1
    endif

    let l:st_str = ""
    for l:st in l:st_list2
        let l:st_str .= l:st
    endfor

    return l:st_str
endfunction
set statusline=%!Set_statusline()

"autocmd local Filetype qf setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%l/%L\ %P
"See $VIMRUNTIME/ftplugin/qf.vim to change quickfix window statusline
"}}}
"}}}

""##########mapping設定 "{{{

"誤って使うとまずいkeymapを削除
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Q <Nop>

"Insert modeを抜けるときにIME off ※ssh先ではhostのを変えるので意味なし
if has("win32")
    inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
endif

"macでinsert modeから抜けるときにIME off
"参考：https://rcmdnk.com/blog/2017/03/10/computer-mac-vim/
if has('mac')
    let g:l_imeoff = 'osascript -e "tell application \"System Events\" to key code 102"'
    autocmd local InsertLeave * :call system(g:l_imeoff)
endif
set ttimeoutlen=1

"使いやすいようにmapping
nnoremap s <c-w>
nnoremap sj <c-w>j
nnoremap s<Down> <c-w>j
nnoremap sk <c-w>k
nnoremap s<Up> <c-w>k
nnoremap sh <c-w>h
nnoremap s<Left> <c-w>h
nnoremap sl <c-w>l
nnoremap s<Right> <c-w>l
"nnoremap T :tablast <bar> :tabnew<space>
nnoremap T :tabnew<space>
nnoremap <silent> co :botright copen<CR>
nnoremap <silent> cc :cclose<CR>
nnoremap <silent> cn :cnewer<CR>
nnoremap <silent> cp :colder<CR>
nnoremap / /\v
nnoremap * /\v<<c-r><c-w>><CR>
nnoremap g<Right> gt
nnoremap g<Left> gT
nnoremap gl gt
nnoremap gh gT
nnoremap <silent> 0gt :tablast<CR>
nnoremap <silent> g> :tabmove +1<CR>
nnoremap <silent> g< :tabmove -1<CR>
"大文字にするとファイル全体に適用
nnoremap zO zR
nnoremap zC zM
"Yで行末までヤンク
nnoremap Y y$
vnoremap Y $y
"そしてenterで開く下を追加したので消そうと思ったけど、macだとうまくいかなかったので残す
"nnoremap <silent> <CR><CR> za
"右方向で再帰的に開く
nnoremap <expr> l foldclosed(line('.')) != -1 ? 'zO' : 'l'
nnoremap <expr> <Right> foldclosed(line('.')) != -1 ? 'zO' : 'l'
"Enterで１段開いたり閉じたりする
nnoremap <expr> <CR> foldlevel('.') != 0 ? 'za' : '<CR>'

"shiftは逆動作だと思ってるので、単語移動をremap
noremap W b
noremap gw W
noremap gW B
noremap E ge
noremap ge E

"ヘッダーファイルをタブで開く
nnoremap gf <c-w>gf

"quick fix windowを新規windowで開いたとき、]でもとのwindowに戻る
"autocmd local Filetype qf nnoremap <buffer> ] <c-w>k <c-w>l
"quick fix windowでc-tで新しいtabで開く
autocmd local Filetype qf nnoremap <buffer><silent> <c-t> <c-w><s-t><CR>:cclose<CR>

"候補が複数ある場合にリストを表示
nnoremap <c-]> g<c-]>
"
nnoremap <silent> g<c-]> :vertical stjump<CR>
"preview で開く
nnoremap <silent> <c-l> :execute("ptjump " . expand("<cword>"))<CR>

"\で検索のハイライトを消す
nnoremap <silent> \ :nohlsearch<CR>

" preview windowはqで閉じる
nnoremap <expr> <silent> q &previewwindow==0 ? 'q' : ':quit<CR>'

"terminal mode設定
"terminal-job modeからterminal-normal modeへの移行をescapeで行えるようにする
tnoremap <ESC> <c-\><c-n>

" }}}

""##########autocmd系 "{{{
autocmd local BufEnter * let b:no_match_paren = 1   " tentative? because of paren error (Highlight_matching_Pair()).

" remove tags information when open new tab.
if exists("*settagstack")
    autocmd local TabNew * call settagstack(winnr(), {'length':0, 'curidx':1, 'items':[]})
endif

" toml fileのfiletypeをtomlにする
autocmd local BufEnter *.toml set filetype=toml

" }}}

""########## (簡単な)作成関数とか{{{
"ls in vim
command! LS 0tabnew .

"vimでbinary fileを見る "{{{
function! FT_Binary(on_off)
    if a:on_off == 1
        if exists("t:l_old_ft")
            echo "already open as binary editor"
            return
        endif
        "前の値を避難させる
        let t:l_old_ft = &filetype
        "let t:l_old_disp = &display
        "binay modeで開く
        if ! exists("t:l_pp_bin")
            e ++bin
            let t:l_pp_bin = 0
        endif
        "不可視文字をHexフォーマットで
        "set display=uhex
        "バイナリエディタっぽく
        %!xxd
        set filetype=xxd

        "nnoremap :q :execute "%!xxd -r"<CR> :q
        "nnoremap :wq :execute "%!xxd -r"<CR> :wq

    else
        if ! exists('t:l_old_ft')
            echo "not opened as binary editor yet"
            return
        endif
        %!xxd -r
        "e ++nobin
        "execute "set display=" . t:l_old_disp
        execute "set filetype=" . t:l_old_ft

        "unmap :wq
        "unmap :q
        unlet t:l_old_ft
        "unlet t:l_old_disp

    endif
endfunction

command! FTBinOn call FT_Binary(1)
command! FTBinOff call FT_Binary(0)
" }}}

"ファイルが読み込めない事があるので、その時用にread onlyをつけてencodeし直して開く関数 "{{{

function! s:noeol_reenc()
    if &endofline == 0
        if input("reencode? 'y' or 'n'")=='y'
            set readonly
            e ++enc=utf-8
        endif
    endif
endfunction

"そしてファイルを開くたびに行うようにautocmd化
autocmd local BufRead * :call s:noeol_reenc()
" }}}

"tabの表示を快適に {{{
" https://qiita.com/wadako111/items/755e753677dd72d8036d
" Anywhere SID.
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

" Set tabline.
" total tab number
let g:l_AllTabNo = 10
function! s:my_tabline() 
    "let endplus = 3
    "if g:l_AllTabNo < 6
        let endplus = g:l_AllTabNo/2
    "endif
    let st = 1
    let en = tabpagenr('$')
    let beginstr = ''
    let laststr = ''
    let is_edit = ''
    "  以降の例は all no = 10 end plus = 3
    if g:l_AllTabNo < en  "tabが指定数より多い場合 例では全ファイル数は13
        if tabpagenr()+endplus > g:l_AllTabNo " 現在 8とか
            let en = tabpagenr()+endplus
            let laststr = '...'
            if en >= tabpagenr('$')  " 現在11とか。足すと余る場合
                let en = tabpagenr('$')
                let laststr = ''
            endif
            let st = en - (g:l_AllTabNo-1)
        else    " 現在 6とか。
            let en = g:l_AllTabNo
            let laststr = '...'
        endif
    endif
    if st > 1
        let beginstr = '..'
    endif
    let s = ''
    for i in range(1,tabpagenr('$'))
        let bufnrs = tabpagebuflist(i)
        let bufnr = bufnrs[tabpagewinnr(i) - 1]
        if getbufvar(bufnr, '&modified') == 1
            let is_edit = '_*_'
        endif
    endfor
    let s .= is_edit
    let s .= beginstr
    for i in range(st, en)
        let bufnrs = tabpagebuflist(i)
        let bufnr = bufnrs[tabpagewinnr(i) - 1]  " first window, first appears
        let no = i  " display 0-origin tabpagenr.
        let mod = getbufvar(bufnr, '&modified') ? '[+]' : ''
        let title = fnamemodify(bufname(bufnr), ':t')
        if getbufvar(bufnr, '&filetype') == 'qf'
            let title = "QuickFix"
        endif
        let title = '[' . title . ']'
        let s .= '%'.i.'T'
        let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
        let s .= no . ':' . title . mod
        "let s .= mod
        let s .= '%#TabLineFill# '
    endfor
    let s .= laststr
    let s .= '%#TabLineFill#%T%=%#TabLine#'
    return s
endfunction
let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
set showtabline=2 " 常にタブラインを表示
" }}}

"開いているファイル情報を表示（ざっくり）{{{
if has('win32')
    let s:ls = 'dir '
else
    let s:ls='ls -l '
endif
command! FileInfo execute "!" . s:ls . expand('%')
"}}}

" 新しいtabで関数ジャンプする {{{
function! <SID>Tab_Jump()
    let l:ctabnr = tabpagenr()
    let l:cword = expand('<cword>')
    tabnew
    " tag listを初期化
    try
        $pop
    catch
    endtry
    execute "tjump " . l:cword
    if expand("%:t") == ""
        quit
        execute "normal! " . l:ctabnr . "gt"
    endif
endfunction

"jump先をnew tabで開く
nnoremap <silent> <c-j> :call <SID>Tab_Jump()<CR>

" }}}

"clipboardを新しいwindowに保存{{{
function! Show_clipboard()
    """ open ... 1 open 0 ... get back
    execute( winnr('$') . 'wincmd l')
    if &filetype != 'clipboard'
        silent botright vertical 20split ClipBoard
        setlocal noreadonly
        setlocal number
        setlocal noswapfile
        setlocal nobackup
        setlocal noundofile
        setlocal filetype=clipboard
        setlocal buftype=nofile
        setlocal nobuflisted
        setlocal wrap
        setlocal report=9999
    endif
    put *
    wincmd p

endfunction
nnoremap <Leader>p :call Show_clipboard()<CR>
"}}}

"diff系command {{{

command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis
command! -nargs=1 -complete=file Diff vertical diffsplit <args>
"}}}

"" active window {{{

"let g:l_cur_winnr = 1
"autocmd local WinEnter let g:l_cur_winnr = winnr()
autocmd local WinEnter ?* set statusline=%!Set_statusline()
autocmd local WinLeave ?* setlocal statusline=%!Set_statusline(g:l_statusline_off)
""" ?* ... to igonore setting quick-fix window

""}}}

" windowsでterminalコマンドを打った時にgit bashを使えるようにする {{{
function! s:Terminal()
    " https://qiita.com/shiena/items/1dcb20e99f43c9383783
    if has('win32')
        botright split
        " 日本語Windowsの場合`ja`が設定されるので、入力ロケールに合わせたUTF-8に設定しなおす
        " コマンドの存在確認はあとで考える
        let l:env = {
                    \ 'LANG': systemlist('"locale.exe" -iU')[0],
                    \ }

        " remote連携のための設定
        if has('clientserver')
            call extend(l:env, {
                        \ 'GVIM': $VIMRUNTIME,
                        \ 'VIM_SERVERNAME': v:servername,
                        \ })
        endif

        " term_startでgit for windowsのbashを実行する
        call term_start(['bash.exe', '-l'], {
                    \ 'term_name': 'Git',
                    \ 'term_finish': 'close',
                    \ 'curwin': v:true,
                    \ 'cwd': $USERPROFILE,
                    \ 'env': l:env,
                    \ })
    else
        if has('nvim')
            botright split
            terminal
            startinsert
        else
            botright terminal
        endif
    endif
endfunction

command! Terminal call s:Terminal()



" }}}

" self-made functionファイル読み込み
if filereadable(g:vimdir . "rcdir/vimrc.func")
    execute "source " . g:vimdir . "rcdir/vimrc.func"
endif

" }}}

""##########file, directory変数 "{{{
autocmd local BufRead * let b:cfile = expand("%:p")
autocmd local BufRead * let b:cdir = expand("%:p:h")

let g:l_last_file = {'win':'', 'tab':''}
autocmd local WinLeave * let g:l_last_file['win'] = expand("%:p")
autocmd local TabClosed * let g:l_last_file['tab'] = g:l_last_file['win']
command! LastTab execute "tabnew " . g:l_last_file['tab']
command! LastWin execute "vsplit " . g:l_last_file['win']

"検索pathを追加
set path+=../include
if exists("$LD_LIBRARY_PATH")
    set path+=$LD_LIBRARY_PATH
endif
"}}}

""##########ファイル読み込み "{{{
"dein directoryがあれば読み込み
let s:dein_file = g:vimdir . "rcdir/vimrc.dein"
if isdirectory(g:vimdir . 'dein') && filereadable(s:dein_file)
    execute "source " . s:dein_file
endif

"pluginの設定読み込み
let s:plugin_file = g:vimdir . "rcdir/vimrc.plugin"
if (isdirectory(g:vimdir . 'plugin') || isdirectory(g:vimdir . 'dein'))
\ && filereadable(s:plugin_file)
    execute "source " . s:plugin_file
endif

"カラーの変更
let s:color_file = g:vimdir . "rcdir/vimrc.color"
if !has('gui_running')
    try
        colorscheme inkpot
        if filereadable(s:color_file)
            execute "source " . s:color_file
        endif
    catch
        colorscheme desert
    endtry
endif

"local設定ファイル (2nd)
let s:localrc = g:vimdir . 'rcdir/vimrc.mine'
if filereadable(s:localrc)
    execute "source " . s:localrc
endif
"}}}

