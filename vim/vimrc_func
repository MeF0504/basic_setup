"vim script encording setting
scriptencoding utf-8

" vim (almost) self-made function file

"単語のハイライト情報をget "{{{
"from http://cohama.hateblo.jp/entry/2013/08/11/020849
function! s:get_syn_id(transparent)
  let synid = synID(line("."), col("."), 1)
  if a:transparent
    return synIDtrans(synid)
  else
    return synid
  endif
endfunction
function! s:get_syn_attr(synid)
  let name = synIDattr(a:synid, "name")
  let ctermfg = synIDattr(a:synid, "fg", "cterm")
  let ctermbg = synIDattr(a:synid, "bg", "cterm")
  let guifg = synIDattr(a:synid, "fg", "gui")
  let guibg = synIDattr(a:synid, "bg", "gui")
  return {
        \ "name": name,
        \ "ctermfg": ctermfg,
        \ "ctermbg": ctermbg,
        \ "guifg": guifg,
        \ "guibg": guibg}
endfunction
function! s:get_syn_info()
  let baseSyn = s:get_syn_attr(s:get_syn_id(0))
  echo "name: " . baseSyn.name .
        \ " ctermfg: " . baseSyn.ctermfg .
        \ " ctermbg: " . baseSyn.ctermbg .
        \ " guifg: " . baseSyn.guifg .
        \ " guibg: " . baseSyn.guibg
  let linkedSyn = s:get_syn_attr(s:get_syn_id(1))
  echo "link to"
  echo "name: " . linkedSyn.name .
        \ " ctermfg: " . linkedSyn.ctermfg .
        \ " ctermbg: " . linkedSyn.ctermbg .
        \ " guifg: " . linkedSyn.guifg .
        \ " guibg: " . linkedSyn.guibg
endfunction
command! SyntaxInfo call s:get_syn_info()
" }}}

" 開いているfile一覧 {{{
let g:l_cur_tabnr = 0
function! s:file_list() abort
    " tab number
    for i in range(1,tabpagenr('$'))
        let l:tab_files = i
        let l:tab_files .= ' '
        "buffer number of each window
        for j in tabpagebuflist(i)
            let mod = getbufvar(j, '&modified') ? '[+]' : ''
            let l:fname =  '[ ' . fnamemodify(bufname(j),':t') . mod . ' ] '
            "let l:fname =  '[ ' . bufname(j) . mod . ' ] '
            if getbufvar(j, '&filetype') == 'qf'
                let l:fname = '[ QuickFix' . mod . ']'
            endif
            let l:tab_files .= l:fname
        endfor
        if tabpagenr() == i
            echohl Search | echo l:tab_files | echohl None
        else
            echo l:tab_files
        endif
    endfor
    let l:tabnr = input("Tab No. or 'p'revious :>> ")
    if l:tabnr == "p"
        let l:tabnr = g:l_cur_tabnr
    endif
    if (1 <= l:tabnr ) && (l:tabnr <= tabpagenr("$") )
        " get current page number
        let g:l_cur_tabnr = tabpagenr()
        execute("normal! " . l:tabnr . "gt")
    endif
endfunction

command! Tls call s:file_list()

nnoremap <silent> <leader>l :Tls<CR>

" }}}

" window setiing function {{{
function! s:window_mode() abort
    if !exists("s:wmode_on")
        let s:wmode_on = 1
        "save old map
        let g:l_wmode_old_map = {}
        let g:l_wmode_map_strs = ["<right>", "l", "<left>", "h", "<up>", "k", "<down>", "j", "i", "a", "s", "I", "A", "S", "R","+","-"]
        for st in g:l_wmode_map_strs
            let g:l_wmode_old_map[st] = maparg(st, 'n',0,1)
        endfor

        "map change window
        nnoremap <right> <c-w>>
        nnoremap l <c-w>>
        nnoremap <left> <c-w><
        nnoremap h <c-w><
        nnoremap <up> <c-w>+
        nnoremap k <c-w>+
        nnoremap <down> <c-w>-
        nnoremap j <c-w>-
        nnoremap i <Nop>
        nnoremap a <Nop>
        nnoremap s <Nop>
        nnoremap I <Nop>
        nnoremap A <Nop>
        nnoremap S <Nop>
        nnoremap R <Nop>

        "change gui font size
        if has("gui")
            function! s:set_font_size(pm)
                let l:fl = strridx(&guifont, 'h')
                let l:font_size = str2nr(&guifont[fl+1:])
                if a:pm == '-'
                    let l:font_size -= 1
                elseif a:pm == '+'
                    let l:font_size += 1
                else
                    return
                endif
                execute("set guifont=" . &guifont[:l:fl] . l:font_size)
            endfunction

            command! WMPlus call s:set_font_size('+')
            command! WMMinus call s:set_font_size('-')
            nnoremap <silent> + :WMPlus<CR>
            nnoremap <silent> - :WMMinus<CR>
        else
            nmap + +
            nmap - -
        endif

        "show mode in statusline
        set statusline+=\ [WM]
    else
        unlet s:wmode_on
        "remap
        for st in g:l_wmode_map_strs
            let l:st_map = g:l_wmode_old_map[st]
            if l:st_map == {}
                execute( "unmap " . st )
            else
                let l:opt = ''
                if l:st_map['silent']
                    let l:opt .= ' <silent> '
                endif
                if l:st_map['buffer']
                    let l:opt .= ' <buffer> '
                endif
                if l:st_map['nowait']
                    let l:opt .= ' <nowait> '
                endif
                if l:st_map['expr']
                    let l:opt .= ' <expr> '
                endif
                if l:st_map['noremap']
                    let l:map_str = 'nnoremap '
                else
                    let l:map_str = 'nmap '
                endif
                execute(l:map_str . l:opt . l:st_map['lhs'] . " " . l:st_map['rhs'] )
            endif
        endfor
        "delete changing font size command
        if has('gui')
            delcommand WMPlus
            delcommand WMMinus
        endif

        "unlet global variables
        unlet g:l_wmode_old_map
        unlet g:l_wmode_map_strs

        set statusline-=\ [WM]
    endif
endfunction

command! Wmode call s:window_mode()
nnoremap <silent> <Leader>w :Wmode<CR>
" }}}

" Linux like command line {{{
let g:l_prompt = "$ "
function! Terminux(use_system_cmd)

"================== command functions ====================
    function! s:ls(opt) "{{{
        if a:opt == ""
            let l:cur_dir = "."
        else
            let cur_dir = split(a:opt, " ")[0]
        endif
        echo "ls " . l:cur_dir
    endfunction
    "}}}

    function! s:cd(opt) "{{{
        execute("cd " . a:opt)
    endfunction
    "}}}

    function! s:pwd(opt) "{{{
        pwd
    endfunction
    "}}}

    function! s:vi(opt) "{{{
        if a:opt == ""
            echo "no file"
        else
            let l:file = split(a:opt, " ")[0]
            execute("e " . l:file)
        endif
    endfunction
    "}}}


"================== command read functions ====================
    function! s:read_cmd(in_cmd)
        let l:cmd = split(a:in_cmd, " ")[0]
        if exists("*s:" . l:cmd )
            let l:cmd_opt = a:in_cmd[len(l:cmd)+1:]
            execute("call s:" . l:cmd . "\( l:cmd_opt \)")
            return 0
        endif
        return 1
    endfunction

    function! s:system_cmd(in_cmd)
        echo system(a:in_cmd)
        return 0
    endfunction


"================== main loop ====================
    while 1
        let l:in_str = input(g:l_prompt)
        if (l:in_str == "exit") || (l:in_str == "q")
            break
        elseif l:in_str == "cmds"
            echo "\n"
            echo s:cmd_list
        elseif l:in_str != ""
            echo "\n"
            if a:use_system_cmd == 1
                let l:ret = s:system_cmd(l:in_str)
            else
                let l:ret = s:read_cmd(l:in_str)
            endif
            if l:ret != 0
                echo "command not found"
            endif
        else
            echo "\n"
        endif
    endwhile

endfunction
" }}}

" Count Search {{{
" let g:l_sc_enable
" 特殊文字は未対応
" bufferの全ヒット数
let g:l_all_word_cnt = 0
" current lineまでのヒット数
let g:l_cur_word_cnt = 0
function! Search_Count(word) abort
    if !exists("g:l_sc_enable")
        return
    endif
    let g:l_all_word_cnt = 0
    let g:l_cur_word_cnt = 0
    let l:lines = getline(1,'$')
    let l:cur_line = line(".")
    let l:sword = a:word
    let l:sword = substitute(l:sword,"<","","")
    let l:sword = substitute(l:sword,">","","")
    let l:sword = substitute(l:sword,"\\vv","","")
    let l:sword = substitute(l:sword,"\\","","")
    let l:ln = 0
    for l:l in l:lines
        let l:line = l:l
        let l:cnt = stridx(l:line,l:sword)
        while l:cnt != -1
            "echo l:line . "  " . l:cnt
            let g:l_all_word_cnt += 1
            if l:ln <= l:cur_line
                let g:l_cur_word_cnt += 1
            endif
            let l:line = l:line[l:cnt+len(l:sword):]
            let l:cnt = stridx(l:line, l:sword)
        endwhile
        let l:ln += 1
    endfor
    "return g:l_word_cnt
endfunction

if exists("g:l_sc_enable")
    "command! -nargs=1 SC call Search_Count(<f-args>) | execute "/\\v" . <f-args>
    "nnoremap // :SC<space>
    nnoremap <silent> n n :call Search_Count(getreg("/"))<CR>h
    nnoremap <silent> N N :call Search_Count(getreg("/"))<CR>h
    set statusline+=[%{g:l_cur_word_cnt}/%{g:l_all_word_cnt}]
endif
" }}}

