"vim script encording setting
scriptencoding utf-8

" vim (almost) self-made function file

"単語のハイライト情報をget "{{{
"from http://cohama.hateblo.jp/entry/2013/08/11/020849
function! s:get_syn_id(transparent)
  let synid = synID(line("."), col("."), 1)
  if a:transparent
    return synIDtrans(synid)
  else
    return synid
  endif
endfunction
function! s:get_syn_attr(synid)
  let name = synIDattr(a:synid, "name")
  let ctermfg = synIDattr(a:synid, "fg", "cterm")
  let ctermbg = synIDattr(a:synid, "bg", "cterm")
  let guifg = synIDattr(a:synid, "fg", "gui")
  let guibg = synIDattr(a:synid, "bg", "gui")
  return {
        \ "name": name,
        \ "ctermfg": ctermfg,
        \ "ctermbg": ctermbg,
        \ "guifg": guifg,
        \ "guibg": guibg}
endfunction
function! s:get_syn_info()
  let baseSyn = s:get_syn_attr(s:get_syn_id(0))
  echo "name: " . baseSyn.name .
        \ " ctermfg: " . baseSyn.ctermfg .
        \ " ctermbg: " . baseSyn.ctermbg .
        \ " guifg: " . baseSyn.guifg .
        \ " guibg: " . baseSyn.guibg
  let linkedSyn = s:get_syn_attr(s:get_syn_id(1))
  echo "link to"
  echo "name: " . linkedSyn.name .
        \ " ctermfg: " . linkedSyn.ctermfg .
        \ " ctermbg: " . linkedSyn.ctermbg .
        \ " guifg: " . linkedSyn.guifg .
        \ " guibg: " . linkedSyn.guibg
endfunction
command! SyntaxInfo call s:get_syn_info()
" }}}

" 開いているfile一覧 {{{
let g:l_cur_winID = win_getid()
function! s:file_list() abort
    " tab number
    for i in range(1,tabpagenr('$'))
        let l:tab_files = printf("%3d", i)
        let l:tab_files .= ' '
        "buffer number of each window
        for j in tabpagebuflist(i)
            let mod = getbufvar(j, '&modified') ? '[+]' : ''
            let l:fname =  '[ ' . fnamemodify(bufname(j),':t') . mod . ' ] '
            "let l:fname =  '[ ' . bufname(j) . mod . ' ] '
            if getbufvar(j, '&filetype') == 'qf'
                let l:fname = '[ QuickFix' . mod . ']'
            endif
            let l:tab_files .= l:fname
        endfor
        if tabpagenr() == i
            echohl Search | echo l:tab_files | echohl None
        else
            echo l:tab_files
        endif
    endfor
    let l:tabnr = input("Tab No. or 'p'revious :>> ")
    if l:tabnr == "p"
        let l:tabnr = win_id2tabwin(g:l_cur_winID)[0]
    endif
    if (1 <= l:tabnr ) && (l:tabnr <= tabpagenr("$") )
        " get current page number
        let g:l_cur_winID = win_getid()
        execute("normal! " . l:tabnr . "gt")
    endif
endfunction

command! Tls call s:file_list()

nnoremap <silent> <leader>l :Tls<CR>

" }}}

" window setiing function {{{
function! s:window_mode() abort
    if !exists("s:wmode_on")
        let s:wmode_on = 1
        "save old map
        let g:l_wmode_old_map = {}
        let g:l_wmode_map_strs = ["<right>", "l", "<left>", "h", "<up>", "k", "<down>", "j", "i", "a", "s", "I", "A", "S", "R","+","-"]
        for st in g:l_wmode_map_strs
            let g:l_wmode_old_map[st] = maparg(st, 'n',0,1)
        endfor

        "map change window
        nnoremap <right> <c-w>>
        nnoremap l <c-w>>
        nnoremap <left> <c-w><
        nnoremap h <c-w><
        nnoremap <up> <c-w>+
        nnoremap k <c-w>+
        nnoremap <down> <c-w>-
        nnoremap j <c-w>-
        nnoremap i <Nop>
        nnoremap a <Nop>
        nnoremap s <Nop>
        nnoremap I <Nop>
        nnoremap A <Nop>
        nnoremap S <Nop>
        nnoremap R <Nop>

        "change gui font size
        if has("gui")
            function! s:set_font_size(pm)
                let l:fl = strridx(&guifont, 'h')
                let l:font_size = str2nr(&guifont[fl+1:])
                if a:pm == '-'
                    let l:font_size -= 1
                elseif a:pm == '+'
                    let l:font_size += 1
                else
                    return
                endif
                execute("set guifont=" . &guifont[:l:fl] . l:font_size)
            endfunction

            command! WMPlus call s:set_font_size('+')
            command! WMMinus call s:set_font_size('-')
            nnoremap <silent> + :WMPlus<CR>
            nnoremap <silent> - :WMMinus<CR>
        else
            nmap + +
            nmap - -
        endif

        "show mode in statusline
        "set statusline+=\ [WM]
        let s:old_st = &statusline
        let &statusline = "%f%m%r%h%w  %=[wimdow mode on]"
    else
        unlet s:wmode_on
        "remap
        for st in g:l_wmode_map_strs
            let l:st_map = g:l_wmode_old_map[st]
            if l:st_map == {}
                execute( "unmap " . st )
            else
                let l:opt = ''
                if l:st_map['silent']
                    let l:opt .= ' <silent> '
                endif
                if l:st_map['buffer']
                    let l:opt .= ' <buffer> '
                endif
                if l:st_map['nowait']
                    let l:opt .= ' <nowait> '
                endif
                if l:st_map['expr']
                    let l:opt .= ' <expr> '
                endif
                if l:st_map['noremap']
                    let l:map_str = 'nnoremap '
                else
                    let l:map_str = 'nmap '
                endif
                execute(l:map_str . l:opt . l:st_map['lhs'] . " " . l:st_map['rhs'] )
            endif
        endfor
        "delete changing font size command
        if has('gui')
            delcommand WMPlus
            delcommand WMMinus
        endif

        "unlet global variables
        unlet g:l_wmode_old_map
        unlet g:l_wmode_map_strs

        "set statusline-=\ [WM]
        let &statusline = s:old_st
    endif
endfunction

command! Wmode call s:window_mode()
nnoremap <silent> <Leader>w :Wmode<CR>
" }}}

""" #で行末から括弧を見つけたり、次のcase文を見つけたりしてとぶ {{{
function! <SID>chk_braket_python()
    " これから作る
    return ""
endfunction

function! <SID>chk_braket()
    """ language specific type
    if &filetype == "vim"
        let l:bra = "if if function for"
        let l:ak = "else elseif None None"
        let l:ket = "endif endif endfunction endfor"
    elseif (&filetype == "c") || (&filetype == "cpp")
        let l:bra = "#if #ifdef #ifndef switch"
        let l:ak = "#else #else #else case"
        let l:ket = "#endif #endif #endif default"
    elseif (&filetype == "python")
        let l:res = <SID>chk_braket_python()
        if l:res != ""
            return l:res
        endif
    else
        let l:bra = ""
        let l:ak = ""
        let l:ket = ""
    endif

    " configure {{{
    if &expandtab
        let l:tab = " "
    else
        let l:tab = "\t"
    endif

    let l:braList = split(l:bra, ' ')
    let l:akList = split(l:ak, ' ')
    let l:ketList = split(l:ket, ' ')

    if len(l:braList) != len(l:akList)
        echo "list length don't match."
        return ""
    endif
    if len(l:braList) != len(l:ketList)
        echo "list length don't match."
        return ""
    endif
    " }}}

    for i in range(0, len(l:braList)-1)
        let b = l:braList[i]
        let a = l:akList[i]
        let k = l:ketList[i]
        if a == "None"
            let a = ''
        endif

        let l:cline = split(getline("."), l:tab)
        if len(l:cline) == 0
            return
        endif

        " start from bra or ak {{{
        if (l:cline[0][:len(b)-1] == b) || (l:cline[0][:len(a)-1] == a)
            let l:count = 1
            for l in range(line('.')+1, line('$'))
                let l:linestr = split(getline(l), l:tab)
                if len(l:linestr) == 0
                    continue
                endif
                " find bra ... count up.
                if l:linestr[0][:len(b)-1] == b
                    let l:count += 1
                    continue
                endif
                " find ak ... if count=1, finish
                if l:linestr[0][:len(a)-1] == a
                    if l:count == 1
                        return l . "gg"
                    endif
                endif
                " find ket ... if count=1, finish. else, count down
                if l:linestr[0][:len(k)-1] == k
                    if l:count == 1
                        return l . "gg"
                    else
                        let l:count -= 1
                        continue
                    endif
                endif
            endfor
        " }}}
        " start from ket {{{
        elseif (l:cline[0][:len(k)-1] == k)
            let l:count = 1
            for ltmp in range(1, line('.')-1)
                let l = line('.') - ltmp
                let l:linestr = split(getline(l), l:tab)
                if len(l:linestr) == 0
                    continue
                endif
                " find bra ... if count=1, finish. else, count down
                if l:linestr[0][:len(b)-1] == b
                    if l:count == 1
                        return l . "gg"
                    else
                        let l:count -= 1
                        continue
                    endif
                endif
                " find ket ... count up.
                if l:linestr[0][:len(k)-1] == k
                    let l:count += 1
                    continue
                endif
            endfor
        endif
        " }}}
    endfor

    """ find braket {{{
    let l:src_strs = ["{", "(", "[", "}", ")", "]"]
    for l:ss in l:src_strs
        let l:idx = strridx(getline("."), l:ss)
        if l:idx == -1
            continue
        endif
        if l:idx == len(getline("."))-1
            return "$%"
        else
            return "$F" . l:ss . "%"
        endif
    endfor
    " }}}
    return ""
endfunction
nnoremap <expr> # <SID>chk_braket()
vnoremap <expr> # <SID>chk_braket()

" }}}

