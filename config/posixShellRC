# POSIX compliant shell Run Command file.
# vim: set filetype=sh:

# checker:: https://www.shellcheck.net/
# memo:: https://qiita.com/richmikan@github/items/bd4b21cf1fe503ab2e5c

##{{{ Environment variable configuration
#
# LANG
#
export LANG=ja_JP.UTF-8
case $(id -u) in
0)
    LANG=C
    ;;
esac

export XDG_CONFIG_HOME=~/.config

# sourceなら$0で行けるかと思ったけど，zshだとsourceでも$0がスクリプト名になる
# ので，https://tkuchiki.hatenablog.com/entry/2014/05/08/222135 を参考にした
# sourceならプロセスは変わらないので，$$でOK
if  ps -p $$ | grep -qs zsh ; then
    export SHELL_INFO=' Z'
elif ps -p $$ | grep -qs bash ; then
    export SHELL_INFO='ba'
elif ps -p $$ | grep -qs ' sh' ; then
    # shは全部に当てはまっちゃうので' sh'で探す
    export SHELL_INFO='sh'
else
    export SHELL_INFO='??'
fi
# vim上で開いてたらv, 他はshellの深さ -> https://www.atmarkit.co.jp/flinux/rensai/linuxtips/529shelldep.html
if [[ -n $VIM ]]; then
    export SHELL_INFO="${SHELL_INFO}-v"
else
    export SHELL_INFO="${SHELL_INFO}-${SHLVL}"
fi
#}}}

##{{{ Alias configuration

# search command
alias where="command -v"

alias j="jobs -l"

# ls
case "$(uname)" in
FreeBSD*|Darwin*)
    alias ls="ls -G -w"
    ;;
Linux*)
    alias ls="ls --color -F"
    ;;
esac

alias la="ls -a"
alias lf="ls -F"
alias ll="ls -l"

# shortcut
alias l="ls"
alias c="cd"

# check if already exists
alias cp="cp -i"
alias mv="mv -i"

# make directory recursively
alias mkdir="mkdir -p"

# change the unit
alias du="du -h"
alias df="df -h"

alias su="su -l"
alias grep="grep --color"

# vim
alias vi='vim -p'

# move files to trash.
alias del="mv_Trash.py"

## if use terminology [https://www.enlightenment.org/about-terminology.md]
if [ "$TERMINOLOGY" = 1 ]; then
    _ls_wrapper()
    {
        if [ "$#" -eq 0 ]; then
            tyls -m
        else
            ls $@
        fi
    }
    alias ls="_ls_wrapper"
fi

## remote host
if [ "$SSH_CLIENT" != "" ]; then
    alias su='echo "su is not available in remote host"'
    alias sudo='echo "sudo is not available in remote host"&&'
fi

if [ "${VIM_TERMINAL}"  != "" ]; then
    alias vim="echo 'already opened vim.'"
    alias vi="echo 'already opened vim.'"
fi

alias global_ip="curl ifconfig.io 2> /dev/null"
alias iv='for iv in {4..1}; do; echo -n ${iv}..\ ;sleep 1;done; echo'

# OS specified aliases
if [ "$(uname)" = "Darwin" ]; then
    alias ldd="echo 'in macOS, ldd doesn't exist. && echo 'Use otool -L instead.' && echo '----------' &&  otool -L"
    alias cpu_temp='sudo powermetrics -n 1 | grep temperature'
elif [ "$(uname)" = "Linux" ]; then
    : # do nothing now.
fi

#}}}

##{{{ terminal configuration

# https://gist.github.com/thomd/7667642
case "${TERM}" in
xterm|xterm-color|xterm-256color)
    export LSCOLORS=Exfxcxdxbxegedabagbcbd
    export LS_COLORS='di=94:ln=35:so=32:pi=33:ex=31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;31:ow=43;31'
    ;;
kterm-color)
    stty erase '^H'
    export LSCOLORS=Exfxcxdxbxegedabagbcbd
    export LS_COLORS='di=94:ln=35:so=32:pi=33:ex=31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;31:ow=43;31'
    ;;
kterm)
    stty erase '^H'
    ;;
cons25)
    unset LANG
    export LSCOLORS=ExFxCxdxBxegedabagacad
    export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
    ;;
jfbterm-color)
    export LSCOLORS=gxFxCxdxBxegedabagacad
    export LS_COLORS='di=01;36:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
    ;;
esac

#}}}

## {{{added functions

add_env() {
    # {{{
    local echo_usage="
    usage: add_env [-h] [-dv] dir

    add dir/*/bin to PATH
    add dir/*/lib and dir/*/lib64 to LIBRARY_PATH & LD_LIBRARY_PATH
    add dir/*/share/man to MANPATH
    ignore directories starts with '_'

    positional arguments:
        dir    : path to the target directory

    optional arguments:
        -h, --help   show this help message and exit
        -d           also add dir/*/lib and dir/*/lib64 to DYLD_LIBRARY_PATH
        -v           show the verbose.
    "

    local dyn=0
    local verbose=0
    local in_dir=''

    ## argument analysis https://qiita.com/b4b4r07/items/dcd6be0bb9c9185475bb
    # typeset -i tmpargc=0
    # typeset -a tmpargv=()
    # echo argv $argv
    # echo argc $argc
    # $argv is the default variable of zsh. don't use it as a local variable.

    if (( $# == 0 )); then
        echo "$echo_usage"
        return
    fi
    while (( $# > 0 ))
    do
        case $1 in
            -*)
                if [[ "$1" =~ 'h' ]]; then
                    echo "$echo_usage"
                    return
                fi
                if [[ "$1" =~ 'd' ]]; then
                    dyn=1
                fi
                if [[ "$1" =~ 'v' ]]; then
                    verbose=1
                fi
                shift
                ;;
            *)
                in_dir="$1"
                shift
                ;;
        esac
    done
    if [[ ${in_dir: -1:1} = '/' ]]; then
        # remove '/' at end
        in_dir=${in_dir%/}
    fi

    find "$in_dir" -mindepth 1 -maxdepth 1 \( -type d -o -type l \) \
        | while read -r basedir
    do
        if [[ $verbose = 1 ]]; then echo "  @ $basedir"; fi
        local bname=
        bname="$(basename "$basedir")"
        if [ "${bname:0:1}" = "_" ]; then
            if [[ $verbose = 1 ]]; then echo 'skip'; fi
            continue
        fi
        ### bin
        if [[ -d "$basedir"/bin && ! $PATH =~ .*"$basedir"/bin:.* ]]; then
            export PATH=$basedir/bin:$PATH
            if [[ $verbose = 1 ]]; then echo "add $basedir/bin to PATH"; fi
        fi
        ### lib
        if [[ -d "$basedir"/lib && ! $LD_LIBRARY_PATH =~ .*"$basedir"/lib:.* ]]; then
            # LIBRARY_PATH is for build? LD_LIBRARY_PATH is for execute?
            export LIBRARY_PATH=$basedir/lib:$LIBRARY_PATH
            export LD_LIBRARY_PATH=$basedir/lib:$LD_LIBRARY_PATH
            if [[ $verbose = 1 ]]; then echo "add $basedir/lib to LIBRARY_PATH & LD_LIBRARY_PATH"; fi
        fi
        if [[ "$dyn" = "1" && -d "$basedir"/lib && ! $DYLD_LIBRARY_PATH =~ .*"$basedir"/lib:.* ]]; then
            export DYLD_LIBRARY_PATH=$basedir/lib:$DYLD_LIBRARY_PATH
            if [[ $verbose = 1 ]]; then echo "add $basedir/lib to DYLD_LIBRARY_PATH"; fi
        fi
        ### lib64
        if [[ -d "$basedir"/lib64 && ! $LD_LIBRARY_PATH =~ .*"$basedir"/lib64:.* ]]; then
            export LIBRARY_PATH=$basedir/lib64:$LIBRARY_PATH
            export LD_LIBRARY_PATH=$basedir/lib64:$LD_LIBRARY_PATH
            if [[ $verbose = 1 ]]; then echo "add $basedir/lib64 to LIBRARY_PATH & LD_LIBRARY_APTH"; fi
        fi
        if [[ "$dyn" = "1" && -d "$basedir"/lib64 && ! $DYLD_LIBRARY_PATH =~ .*"$basedir"/lib64:.* ]]; then
            export DYLD_LIBRARY_PATH=$basedir/lib64:$DYLD_LIBRARY_PATH
            if [[ $verbose = 1 ]]; then echo "add $basedir/lib64 to DYLD_LIBRARY_PATH"; fi
        fi
        ## man
        if [[ -d "$basedir"/share/man && ! $MANPATH =~ .*"$basedir"/share/man:.* ]]; then
            if [[ $verbose = 1 ]]; then echo "add $basedir/share/man to MANPATH"; fi
            export MANPATH=$basedir/share/man:$MANPATH
        fi
    done
# }}}
}

weather() {
    # {{{
    # Tokyo, Sapporo, SanFrancisco, moon, etc..
    if [[ "$1" =~ "-h" ]]; then
        echo "usage: weather city"
        echo "e.g. 'weather Tokyo', 'weather America California', 'weather moon' etc."
        return
    fi
    local city=$1
    for x in "${@:2}"; do
        city=$city+$x
    done
    curl wttr.in/"$city"
# }}}
}

del_func() {
    # {{{
    del_trash=${del_trash:-$HOME/.Trash}
    # https://qiita.com/tdrk/items/cc2995fd74e659ea948f
    if [[ ! -d "${del_trash}" ]]; then
        \mkdir -p "${del_trash}"
    fi
    footer=$(date "+%m%d_%H%M%W")
    for fp in "$@"; do
        if [[ ! -e "$fp" ]] && [[ ! -d "$fp" ]]; then
            echo "$fp doesn't exist"
            continue
        fi
        touch "$fp"   # update timestamp.
        fn=$(basename "${fp}")
        if [[ -e "${del_trash}"/"${fn}" ]]; then
            \mv "$fp" "${del_trash}"/"${fn}"_"${footer}"
        else
            \mv "$fp" "${del_trash}"
        fi
    done
# }}}
}
# I recommend using mv_Trash.py if possible.
# alias del=del_func

mkcd() {
    # {{{
    if [[ ! -d "$1" ]]; then
        echo mkdir "$1"
        mkdir -p "$1"
    fi
    \cd "$1"
    # }}}
}

timeout_local() {
    # {{{
    # https://qiita.com/yohm/items/db6aea3cbc71ab2d55bd
    time=$1

    # start the command in a subshell to avoid problem with pipes
    # (spawn accepts one command)
    command="/bin/sh -c \"${@:2}\""

    /usr/bin/expect -c "set timeout $time; spawn -noecho $command; expect timeout { exit 124 } eof; catch wait result; exit [lindex \$result 3];"
    # }}}
}

echoenv() {
    # {{{
    echo -ne "${*//:/\\n}"
    echo ''
    # }}}
}

get_term_name() {
    # teminal で何を使っているのか判別する方法を忘れないように {{{
    if [[ -n "${ITERM_SESSION_ID}" ]]; then
        echo 'iTerm.app'
    elif [[ -n "${TERMINATOR_UUID}" ]]; then
        echo 'Terminator'
    elif [[ -n "${TERMINOLOGY}" ]]; then
        echo 'Terminology'
    elif [[ -n "${WT_SESSION}" ]]; then
        echo 'Windows_Terminal'
    elif [[ -n "${TERM_PROGRAM}" ]]; then
        echo "${TERM_PROGRAM}"
    fi
    # }}}
}

# open manual in vim
manvim() {
    # https://rcmdnk.com/blog/2014/07/20/computer-vim/
    man $@ 2>&1 | col -bx | vim -R -c 'set ft=man nolist nomod noma' -
}

#}}}

